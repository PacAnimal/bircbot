#!/usr/bin/env bash

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, June 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/gpl-2.0.html>

# Copyright 2006-2020 - Cathedral Networks	 <admin@cathedral-networks.org>

# Description:
#
# Somewhat useful shell functions, mostly developed for internal use
#
# Please note: Some of these are likely broken, or written to suit a very
#			   specialized scenario. Please read each function carefully
#			   before use, to ensure you know what it does
#

# include guard (..ish)
if [[ -z "${_sf_loaded:-}" ]]; then
	_sf_loaded=true
else
	return 0
fi

# needed for runfunc to find the functions
_shellfunc_header="sf_"

# safe echo
function sf_print { builtin printf '%s' "$*"; }
function sf_println { builtin printf '%s\n' "$*"; }
function sf_print2 { sf_print "$@" >&2; }
function sf_println2 { sf_println "$@" >&2; }
function sf_print0 { builtin printf '%s\0' "$*"; }

# deprecation
function _sf_deprecated { sf_println2 "Warning: ${FUNCNAME[1]} is deprecated!"; }

# deprecated print functions
function sf_stdout { _sf_deprecated; { echo -e "$@"; } 2>/dev/null; }
function sf_stdoutv { _sf_deprecated; ! ${_sf_verbose:-true} || sf_stdout "$@"; }
function sf_stdouti { _sf_deprecated; ! sf_terminal || sf_stdout "$@"; }
function sf_usage { _sf_deprecated; sf_println2 "Usage: $*"; }
function sf_stderr { _sf_deprecated; echo -e "$@" >&2; }
function sf_stderrv { _sf_deprecated; ! ${_sf_verbose:-true} || sf_println2 "$@"; }
function sf_stderri { _sf_deprecated; ! sf_terminal || sf_println2 "$@"; }
function sf_info { _sf_deprecated; sf_println2 "Info:" "$@"; }
function sf_infov { _sf_deprecated; ! ${_sf_verbose:-true} || sf_println2 "Info:" "$@"; }
function sf_infoi { _sf_deprecated; ! sf_terminal || sf_println2 "Info:" "$@"; }
function sf_warning { _sf_deprecated; sf_println2 "Warning:" "$@"; }
function sf_warningv { _sf_deprecated; ! ${_sf_verbose:-true} ||  sf_println2 "Warning:" "$@"; }
function sf_warningi { _sf_deprecated; ! sf_terminal || sf_println2 "Warning:" "$@"; }
function sf_error { _sf_deprecated; sf_println2 "Error:" "$@"; }
function sf_errorv { _sf_deprecated; ! ${_sf_verbose:-true} || sf_println2 "Error:" "$@"; }
function sf_errori { _sf_deprecated; ! sf_terminal || sf_println2 "Error:" "$@"; }
function sf_error_tput { _sf_deprecated; sf_println2 "Error: tput does not function correctly on your terminal!"; }

# error messages
function sf_error_unknown_option { sf_println2 "Error: Unknown option -${OPTARG}"; }
function sf_warning_unknown_option { sf_println2 "Warning: Unknown option -${OPTARG}"; }
function sf_error_missing_argument { sf_println2 "Error: Option -${OPTARG} requires an argument"; }

# print a message within an 80 character wide line
function sf_line80
{
	local stderr=false prenewline=false postnewline=false parens=true symbol="="

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":ehnNs" opt; do
		case "$opt" in
			e) stderr=true ;;
			s) symbol="-" ;;
			h) symbol="#"; parens=false ;;
			n) prenewline=true ;;
			N) postnewline=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# > 2 )); then
		sf_println2 "Usage: $FUNCNAME <string> [length (int)]"
		return 1
	fi

	local string
	read -r string <<<"${1:-}"
	if [[ -n "$string" ]]; then
		string=" ${string} "
		if $parens; then
			string="(${string})"
		fi
	fi

	if [[ -n "${2:-}" ]]; then
		sf_integer -v "$2" || return $?
		local width=$(( $2 > 0 ? $2 + $((parens ? 4 : 2)) : 0 ))
	else
		local width=${#string}
	fi

	if (( width > 78 )); then
		sf_println2 "Warning: Text too long for $FUNCNAME: $1"
		return 1
	fi

	local right=$(( 40 - width / 2 ))
	local left=$(( right - width % 2 ))

	left=$(printf "%${left}s" "")
	right=$(printf "%${right}s" "")

	if $stderr; then
		! $prenewline || sf_println2
		sf_println2 "${left// /$symbol}${string}${right// /$symbol}"
		! $postnewline || sf_println2
	else
		! $prenewline || sf_println
		sf_println "${left// /$symbol}${string}${right// /$symbol}"
		! $postnewline || sf_println
	fi
}

# copy a function (will not overwrite existing ones)
function sf_fcopy
{
	if (( $# != 2 )); then
		sf_println2 "Usage: $FUNCNAME <source> <destination>"
		return 1
	fi

	if ! declare -f "$1" >/dev/null; then
		sf_println2 "Error: $FUNCNAME: source function $1 is not defined!"
		return 1
	fi

	if declare -f "$2" >/dev/null; then
		return 1
	fi

	eval "$(declare -f "$1" | sed "0,/${1}/{s/${1}/${2}/}")"
}

# get unix time
function sf_unixtime { date "$@" +'%s'; }
function sf_unixtime_ms { date "$@" +'%s%N' | head -c -7; }
function sf_unixtime_us { date "$@" +'%s%N' | head -c -4; }
function sf_unixtime_ns { date "$@" +'%s%N'; }

# get a standard cathedral timestamp
function sf_timestamp { date "$@" +'%Y-%m-%d %H:%M:%S %z'; }
function sf_timestampZ { date "$@" +'%Y-%m-%d %H:%M:%S %Z'; }
function sf_timestamp_short { date "$@" +'%Y-%m-%d %H:%M:%S'; }

# get a military style date
function sf_date { date "$@" +'%Y%m%d'; }

# get a timestamp for backup filenames
function sf_timestamp_backup { date "$@" +"%Y%m%dT%H%M%S"; }

# check if we're online
function sf_online
{(
	local ipopt='--prefer-family=IPv4'

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":46" opt; do
		case "$opt" in
			4) ipopt="--inet4-only" ;;
			6) ipopt="--inet6-only" ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	function check
	{
		if sf_timeout -s9 30 wget $ipopt --spider --timeout=28 --tries=1 -o /dev/null -O /dev/null "$@" >/dev/null 2>&1; then
			return 0
		fi
		sleep 1
		return 1
	}

	if
		check google.com || check microsoft.com || check debian.org || check kernel.org
	then
		return 0
	else
		return 1
	fi
)}

# get the size of a file in bytes
function sf_size
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi

	if ! [[ -e "$1" ]]; then
		sf_println2 "Error: \"${1}\" does not exist!"
		return 1
	fi

	stat --printf "%s" "$1"
}

# get the access-time on a file in seconds since epoch
function sf_atime
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi

	if ! [[ -e "$1" ]]; then
		sf_println2 "Error: \"${1}\" does not exist!"
		return 1
	fi

	case "$(sf_sysver)" in
		*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*|Linux)
			stat -c '%X' "$1"
		;;
		FreeBSD*)
			stat -f '%a' "$1"
		;;
		*)
			sf_println2 "Error: No idea how to get atime on: $(sf_sysver)"
		;;
	esac
}


# get the modify-time on a file in seconds since epoch
function sf_mtime
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi

	if ! [[ -e "$1" ]]; then
		sf_println2 "Error: \"${1}\" does not exist!"
		return 1
	fi

	case "$(sf_sysver)" in
		*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*|Linux)
			stat -c '%Y' "$1"
		;;
		FreeBSD*)
			stat -f '%m' "$1"
		;;
		*)
			sf_println2 "Error: No idea how to get mtime on: $(sf_sysver)"
		;;
	esac
}

# support for old sudo versions in scripts
function sf_sudo
{
	if sudo -nl >/dev/null 2>&1 <<<""; then
		if sudo -n true 2>/dev/null; then
			sudo -n "$@"
		else
			sf_println2 "Warning: This script requires root permissions."
			return 1
		fi
	else
		sf_println2 "Warning: Outdated sudo version without -n switch - the script may get stuck here"
		sudo "$@"
	fi
}

# get files and permissions recursively
function sf_permsave
{
	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <dir> [dir] ..."
		return 1
	fi

	while [[ -n "${1:-}" ]]; do
		find "$1" -printf '%u\0%U\0%g\0%G\0%m\0%p\0%l\0'
		shift
	done
}

# set permissions recursively from a file
function sf_permload
{
	local numeric=false
	local dryrun=false
	local yes=false
	local user uid group gid perms file target

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":dny" opt; do
		case "$opt" in
			d) dryrun=true ;;
			n) numeric=true ;;
			y) yes=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <file> [file] ..."
		return 1
	fi

	if ! $dryrun && ! $yes; then
		sf_println2
		sf_println2 "This will read the provided files and overwrite permissions on the files described inside!"
	fi
	if $dryrun || $yes || sf_question -N "Are you sure you want to do this?"; then
		while [[ -n "${1:-}" ]]; do
			if ! sf_goodfile -v "$1" >/dev/null; then
				return 1
			fi
			while
				for i in user uid group gid perms file target; do
					IFS= read -r -d $'\0' "$i"
				done
			do
				sf_println "${user}(${uid}) - ${group}(${gid}) - ${perms} - ${file}${target:+ => $target}"
				if ! [[ -e "$file" ]]; then
					sf_println2 "File not found: $file"
					continue
				fi
				if ! $dryrun; then
					if [[ -n "$target" ]]; then
						rm -rf "$file" 2>/dev/null || :
						ln -sf "$target" "$file"
					else
						if $numeric; then
							chown "${uid}:${gid}" "$file"
						else
							chown "${user}:${group}" "$file"
						fi
						chmod "$perms" "$file"
					fi
				fi
			done <"$1"
			shift
		done
	fi
}

# get the delta modify-time on a file in seconds from now (positive values for negative time, -60 is one minute in the future)
function sf_dmtime
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi
	local mtime unixtime
	mtime=$(sf_mtime "$1") || return 1
	unixtime=$(sf_unixtime)
	sf_println $((unixtime-mtime))
}

# trim whitespace
function sf_trim
{
	{
		if ! (( $# )); then
			cat
		else
			sf_println "$@"
		fi
	} | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

# count down
function sf_countdown
{
	if (( $# < 1 )) || (( $# > 2 )); then
		sf_println2 "Usage: $FUNCNAME [string] <integer>"
		return 1
	fi

	local string=""
	if (( $# == 2 )); then
		string=$1
		read -r string <<<"$string"
		shift
	fi

	if ! sf_integer -v -- "$1"; then
		return 1
	fi

	if [[ -n "$string" ]]; then
		sf_print "$string "
	fi

	local i
	for(( i=$1; i>0; i-- )); do
		sf_print "${i}.. "
		sleep 1 || return $?
	done
	sf_println "0!"
}

# is X in the path?
function sf_inpath
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <path>"
		return 1
	fi
	[[ ":${PATH}:" = *":${1}:"* ]]
}

# diff two files, print differences and replace
function sf_diffreplace
{
	local replace=true
	local create=false
	local silent=false

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":ncs" opt; do
		case "$opt" in
			c) create=true ;;
			n) replace=false ;;
			s) silent=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# < 2 )) || (( $# > 3 )); then
		sf_println2 "Usage: $FUNCNAME [-n] <oldfile> <newfile> [description]"
		return 1
	fi

	local old=$1
	local new=$2
	local desc=${3:-${old}}

	if ! sf_goodfile "$old" && $create && ! sf_mkfile -f "$old" >/dev/null; then
		sf_println2 "Error: Failed to create file \"$old\"!!"
		return 1
	fi

	if ! sf_goodfile -wv "$old" >/dev/null || ! sf_goodfile "$new" >/dev/null; then
		return 1
	fi

	$silent || printf '\n%s\n' "Comparing..."
	if ! diff -q "$old" "$new" &>/dev/null; then
		if ! $silent; then
			sf_println2 "Detected a change in \"${desc}\":"
			diff "$old" "$new" >&2 || :
			sf_println2
		fi
		if $replace; then
			if ! $silent; then
				sf_println2 "Installing new version of \"${desc}\""
				sf_println2
			fi
			cat "$new" >"$old"
		fi
		return 0 # file was, or should be, replaced
	else
		$silent || printf '%s\n\n' "No change"
		return 1
	fi
}

# recursively kill processes
function sf_killtree
{
	local pids ppid=$1 sig=${2:-"TERM"}
	if ! kill -0 "$ppid"; then
		sf_println2 "killtree: ($ppid) - No such process"
		return 1
	fi
	(( ppid == $$ )) || kill -STOP "$ppid" 2>/dev/null || :
	mapfile -t pids < <( { pgrep -P "$ppid" || ps -o pid= --ppid "$ppid" || :; } 2>/dev/null )
	if [[ -n "${pids[*]:-}" ]]; then
		for pid in "${pids[@]}"; do
			sf_killtree "$pid" "$sig" 2>/dev/null || :
		done
	fi
	kill "-${sig}" "$ppid" 2>/dev/null || :
	(( ppid == $$ )) || kill -CONT "$ppid" 2>/dev/null || :
	wait "$ppid" 2>/dev/null || :
}

# kill all child processes of script
function sf_killchildren
{
	local _term
	_term=$(builtin trap -p TERM)
	builtin trap : TERM
	sf_killtree $$ TERM;
	builtin trap - TERM
	builtin eval "$_term"
}

# check if a variable is in an array - usage: sf_inarray "$needle" "${haystack[@]:-}"
function sf_inarray
{
	local needle=$1 haystack
	shift
	for haystack; do
		[[ "$needle" != "$haystack" ]] || return 0
	done
	return 1
}

# join array elements to a string using a given separator
function sf_join
{
	if (( $# < 2 )); then
		sf_println2 "Usage: $FUNCNAME <separator> <array>"
		return 1
	fi
	local sep=$1 i
	sf_print "$2"
	shift 2
	for i; do
		sf_print "${sep}${i}"
	done
	sf_println
}

# evaluate mathematical expressions
function sf_math_eval { (( $(bc -l <<<"$*") )); }

# make a string safe to sed with
function sf_sedsafe
{
	local extended=false

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":r" opt; do
		case "$opt" in
			r) extended=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <string>"
		return 1
	fi

	if $extended; then
		sed 's/[][\.*^$(){}?+|/]/\\&/g' <<<"$1"
	else
		sed 's/[][\.*^$/]/\\&/g' <<<"$1"
	fi
}

# convert from decimal to binary
function sf_dec2bin
{
	local dec=$1 bin=""
	local base2=(0 1)
	while ((dec)); do
		bin="${base2[$((dec % 2))]}$bin"
		dec=$((dec/2))
	done
	[[ -n "$bin" ]] || bin="0"
	local octlen=$((${#bin}/8))
	! ((${#bin}%8)) || printf "%0$(((octlen+1)*8 - ${#bin}))d" "0"
	sf_println "$bin"
}	

# convert from binary to decimal
function sf_bin2dec
{
	sf_println $((2#${1}))
}

# convert an ipv4 to binary
function sf_ipv42bin
{
	local bin="" iparray dec
	IFS='.' read -r -a iparray <<<"$@"
	if ((${#iparray[@]} != 4)); then
		sf_println2 "Error: Not an IPv4 address: $*"
		return 1
	fi
	for dec in "${iparray[@]}"; do
		bin+=$(sf_dec2bin "$dec")
	done
	sf_println "$bin"
}

# convert from binary to ipv4
function sf_bin2ipv4
{
	printf '%s.%s.%s.%s\n' \
		"$(sf_bin2dec "${1:10#00:8}")" \
		"$(sf_bin2dec "${1:10#08:8}")" \
		"$(sf_bin2dec "${1:10#16:8}")" \
		"$(sf_bin2dec "${1:10#24:8}")"
}

# timestamp each line
function sf_stampline
{
	while read -r line; do
		sf_println "$(sf_timestamp_short) $line"
	done
}

# look for changes between a tar archive and a directory
function sf_tardiff
{
	local z=""
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":z" opt; do
		case "$opt" in
			z) z="z" ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 2 )); then
		sf_println2 "Usage: $FUNCNAME <tgz> <dir>"
		return 1
	fi

	file=$1
	dir=$2

	if ! sf_goodfile -vq "$file" || ! sf_gooddir -vq "$dir"; then
		return 1
	fi

	if ! tar "${z}df" "$file" -C "$dir" . >/dev/null 2>&1; then
		return 1
	fi

	local delta
	delta=$(
		{
			tar "${z}tf" "$file" | grep -v '^\.\/$' | sed 's/\/$//g'
			cd "$dir" && find . -mindepth 1
		} | sort | uniq -u | sf_wc -c
	)

	return $(( delta ? 1 : 0 ))
}


# sanitize indents
function sf_indent
{
	local indent=0 tabsize=4
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":i:t:" opt; do
		case "$opt" in
			i)
				indent=$OPTARG
				if ! sf_integer -v -- "$indent"; then
					return 1
				fi
			;;
			t)
				tabsize=$OPTARG
				if ! sf_integer -v -- "$tagsize"; then
					return 1
				fi
			;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# )); then
		sf_println2 "Usage: $FUNCNAME"
		return 1
	fi

	local base data min_space
	printf -v base "%$((indent*tabsize))s"
	data=$(expand -i -t "$tabsize" | base64 -w0)
	min_space=$(
		base64 -d <<<"$data" |
		{
			while IFS='' read -r line; do
			if [[ "$line" =~ ^[[:space:]]*$ ]]; then
				continue
			fi
			[[ "$line" =~ ^( *) ]]
			printf '%d\n' "${#BASH_REMATCH[1]}"
			done
		} |
		sort -n |
		head -n 1 |
		{ grep "^" || printf '0'; }
	)
	base64 -d <<<"$data" | cut -c "$((min_space+1))-" | sed "s/^/${base}/g"
}


# print given fields from output (awk '{print $whatever}')
function sf_fields
{
	local skip=0 delimiter=" " input_delimiter="$IFS"
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":s:d:D:" opt; do
		case "$opt" in
			s)
				skip=$OPTARG
				if ! sf_integer -v -- "$skip"; then
					return 1
				fi
			;;
			D) delimiter=$OPTARG ;;
			d) input_delimiter=$OPTARG ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	local f_min=() f_max=()
	local opt
	for opt; do
		if [[ "$opt" =~ ^-?[0-9]+$ ]]; then
			f_min+=( $((opt-1)) )
			f_max+=( $((opt-1)) )
		elif [[ "$opt" =~ ^[[:digit:]]+-$ ]]; then
			opt=${opt%"-"}
			f_min+=( $((opt-1)) )
			f_max+=( "" )
		elif [[ "$opt" =~ ^[[:digit:]]+-[[:digit:]]+$ ]]; then
			local lower=${opt%%-*}
			f_min+=( $((lower-1)) )
			local upper=${opt##*-}
			f_max+=( $((upper-1)) )
		else
			sf_println2 "Error: ${FUNCNAME}: Invalid field specification: $opt"
			return 1
		fi
	done

	while (( skip-- > 0 )); do
		read -r
	done

	local fields=()
	while IFS="$input_delimiter" read -ra fields; do
		local cnt="${#fields[@]}"
		local i=0
		for ((; i<$#; i++)); do
			local j=${f_min[i]}
			local k=${f_max[i]:-$((cnt-1))}
			for ((; j<=k; j++)); do
				if (( j < cnt )) && (( j >= -cnt )); then
					sf_print "${fields[j]}"
				fi
				if (( i+1 < $# )) || (( j+1 <= k )); then
					sf_print "$delimiter"
				fi
			done
		done
		sf_println
	done
}

# print lines following a given regex
function sf_lines_from
{
	local line print=false skip=0
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":s:" opt; do
		case "$opt" in
			s)
				skip=$OPTARG
				if ! sf_integer -v -- "$skip"; then
					return 1
				fi
			;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <regex>"
		return 1
	fi
	while IFS='' read -r line; do
		$print || ! [[ "$line" =~ $1 ]] || print=true
		if $print; then
			if (( skip )); then
				(( skip-- ))
			else
				sf_println "$line"
			fi
		fi
	done
}

# print lines until a given regex occurs
function sf_lines_to
{
	local line skip=0
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":s:" opt; do
		case "$opt" in
			s)
				skip=$OPTARG
				if ! sf_integer -v -- "$skip"; then
					return 1
				fi
			;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <regex>"
		return 1
	fi
	while IFS='' read -r line; do
		if (( skip )); then
			(( skip-- ))
		elif [[ "$line" =~ $1 ]]; then
			cat >/dev/null
			break
		fi
		sf_println "$line"
	done
}

# check if given ipv4 is a private address, or print a list of private addresses
function sf_ipv4priv
{
	local locnet=(
		"127.0.0.0/8"
		"10.0.0.0/8"
		"172.16.0.0/12"
		"192.168.0.0/16"
	)
	if ! (( $# )); then
		printf '%s\n' "${locnet[@]}"
		return 0
	elif (( $# > 1 )); then
		sf_println2 "Usage: $FUNCNAME <command>"
		return 1
	fi
	local bin ip cmp
	bin=$(sf_ipv42bin "$1") || return $?
	for ip in "${locnet[@]}"; do
		cmp=$(sf_ipv42bin "${ip%%/*}")
		cmp=${cmp:0:${ip##*/}}
		[[ "${bin:0:${ip##*/}}" != "${cmp:0:${ip##*/}}" ]] || return 0
	done
	return 1
}	

# perform a "which" lookup with a clean path
function sf_which
{(
	local verbose=false
	local quiet=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":vq" opt; do
		case "$opt" in
			v) verbose=true ;;
			q) quiet=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <command>"
		return 1
	fi

	local result=""
	case "$(sf_sysver)" in
		*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*|*Arch*|*CentOS*)
			if (( BASH_VERSINFO[0] >= 4 )); then
				result=$(command -p -v "$1" 2>/dev/null) || :
			else
				result=$(/usr/bin/env -i bash -l <<< "which ${1}" 2>/dev/null) || :
			fi
		;;
		FreeBSD*)
			result=$(/usr/bin/env bash -l <<< "which ${1}") || :
		;;
		*)
			sf_println2 "Error: Unable to check for \"${1}\" - \"$(sf_sysver)\" is unsupported!"
		;;
	esac


	if [[ -n "${result:-}" ]]; then
		$quiet || sf_println "$result"
		return 0
	else
		! $verbose || sf_println2 "Error: \"${1}\" was not found on this system!"
		return 1
	fi
)}

# get the system uptime in seconds
function sf_uptime
{
	sf_fields -d '.' 1 </proc/uptime
}

# restart a service
function sf_restartservice
{
	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <service> [service] ..."
		return 1
	fi
	
	while [[ -n "${1:-}" ]]; do
		case "$(sf_sysver)" in
			*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*)
				if [[ -e "/etc/init.d/${1}" ]]; then
					"/etc/init.d/${1}" restart
				else
					sf_println2 "Error: No such service: $1"
					return 1
				fi
			;;
			*)
				sf_println2 "Error: ${FUNCNAME} has no idea how to restart services on this system!"
				sf_println2 "sysver returned: $(sf_sysver)"
				exit 1
			;;
		esac
		shift
	done
}

# octal permissions
function sf_octperm
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi

	case "$(sf_sysver)" in
		*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*|*Arch*|*CentOS*|*RedHat*)
			printf '%03d\n' "$(stat -c "%a" "$1")"
		;;
		FreeBSD*)
			printf '%03d\n' "$(stat -f "%OLp" "$1")"
		;;
		*)
			sf_println2 "Error: No idea how to get octal permissions on $(sf_sysver)!"
		;;
	esac
}

# buffer
function sf_buffer
{
	local buffer
	buffer=$(base64 -w 0)
	if [[ -n "${1:-}" ]]; then
		base64 -d <<<"$buffer" >"$1"
	else
		base64 -d <<<"$buffer"
	fi
}

# netstat
function sf_netstat
{(
	local local_address=""
	local remote_address=""
	local state=""
	local pid=""
	local listen=""

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":lL:p:R:s:" opt; do
		case "$opt" in
			l) listen="l" ;;
			L) local_address=$OPTARG ;;
			R) remote_address=$OPTARG ;;
			p)
				pid=$OPTARG
				if ! sf_integer -v -- "$pid"; then
					return 1
				fi
				pid="${pid}/"
			;;
			s) state=$(sf_toupper <<<"$OPTARG") ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	local alnum='[[:alnum:]][[:alnum:]]*'
	local blank='[[:blank:]][[:blank:]]*'
	local alpha='[[:alpha:]][[:alpha:]]*'
	local digit='[[:digit:]][[:digit:]]*'
	local wildcard='..*'

	local needle='^'
	needle="${needle}${alnum}${blank}${digit}${blank}${digit}${blank}"
	needle="${needle}${local_address:-${wildcard}}${blank}"
	needle="${needle}${remote_address:-${wildcard}}${blank}"
	needle="${needle}${state:-${alpha}}${blank}"
	needle="${needle}${pid:-${wildcard}}"
	
	LC_ALL=C netstat -ntpW${listen} 2>/dev/null | grep "$needle"
)}

# nicer cronjobs - call at start of scripts, supplying "$@" as arguments
# requires sourcing shellfunc
function sf_nicejob
{
	sf_nice
	if (( $# != 0 )) && [[ "$1" == "cron" ]]; then
		sleep $(( RANDOM % 3600 + 1 ))
	fi
}

# validate ipv4 addresses
function sf_ipv4 { [[ "$*" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; }

# resolve a hostname
function sf_lookup
{
	local first=false
	local six=false
	local four_only=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":146" opt; do
		case "$opt" in
			1) first=true ;;
			4) four_only=true ;;
			6) six=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME [-1] [-4] [-6] <hostname>"
		return 1
	fi

	local query=$1
	declare -a v4
	declare -a v6
	local line
	while read -r line; do
		if [[ "$line" = *"."* ]]; then
			v4+=( "$line" )
		else
			v6+=( "$line" )
		fi
	done < <(
		getent hosts "$query" | cut -d ' ' -f1
		while read -r line; do
			if [[ "$line" = *" has address "* ]]; then
				sf_println "${line##* }"
			elif [[ "$line" = *" has IPv6 address "* ]]; then
				sf_println "${line##* }"
			fi
		done < <(host "$query")
	)
	{
		$four_only || ! $six || [[ -z "${v6[*]:-}" ]] || printf '%s\n' "${v6[@]}" | sort | uniq
		[[ -z "${v4[*]:-}" ]] || printf '%s\n' "${v4[@]}" | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n | uniq
		$four_only || $six || [[ -z "${v6[*]:-}" ]] || printf '%s\n' "${v6[@]}" | sort | uniq
	} |
	{
		# abusing grep to get the correct return status for whether or not we printed anything
		if $first; then
			head -n 1 | grep ''
		else
			grep ''
		fi
	}
}

# print a set of parameters, quoting where necessary for shell input
function sf_quote
{
	if [[ -n "${QUOTE_PROMPT:-}" ]]; then
		printf '%s ' "$QUOTE_PROMPT"
	fi
	local s regex='^[-_=/@%+?,:.[:alnum:]]*$' first=true
	for s; do
		if $first; then first=false; else printf ' '; fi
		if (( ${#s} )) && ! [[ "$s" =~ $regex ]]; then
			printf '%s' "${s@Q}"
		else
			printf '%s' "$s"
		fi
	done
	printf '\n'
}

# it's nice to be nice
function sf_nice { renice -n 19 $$ &>/dev/null || :; }

# "save" the screen, like vim does
function sf_termsave
{(
	set +e
	tput smcup
	clear
	return 0
)}
function sf_termrestore
{(
	set +e
	clear
	tput rmcup
	return 0
)}

# check if a directory is empty
function sf_isemptydir
{(
	set -eu
	
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME <dir> [dir] ..."
		exit 1
	fi

	shopt -s nullglob dotglob
	while [[ -n "${1:-}" ]]; do
		(
			if ! cd "$1" 2>/dev/null; then
				exit 1
			fi
			local contents=(*)
			if (( ${#contents[*]} != 0 )); then
				exit 1
			fi
		) || exit 1
		shift
	done
	
	exit 0
)}

# test for a valid port number
function sf_goodport
{(
	local verbose=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":v" opt; do
		case "$opt" in
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <port>"
		return 1
	fi
	
	if
		! sf_integer -- "$1" ||
		(( $1 < 0 )) ||
		(( $1 > 65535 ))
	then
		sf_println2 "Error: \"${1}\" is not a valid port number!"
		return 1
	fi

	! $verbose || sf_println2 "\"${1}\" is a good port"

	return 0
)}

# get current runlevel
function sf_runlevel
{
	local runlevel="/sbin/runlevel"
	if ! sf_goodfile "$runlevel"; then
		if ! runlevel=$(sf_which runlevel); then
			sf_println2 "Error: Unable to determine the location of \"runlevel\"!"
			return 1
		fi
	fi

	$runlevel | sf_fields 2
}

# kill a pid, wait for timeout, then kill some more
function sf_termkill
{(
	set +e

	local sigkill=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":9" opt; do
		case "$opt" in
			9) sigkill=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# == 0 )) || (( $# > 2 )); then
		sf_println2 "Usage: $FUNCNAME [-9] <pid> [timeout]"
		return 1
	fi

	local pid=$1
	local timeout=${2:-"10"}

	if
		! sf_integer -v -- "$pid" ||
		! sf_integer -v -- "$timeout"
	then
		return 1
	fi

	if kill -0 "$pid" 2>/dev/null; then
		local dead=false
		if ! kill -TERM "$pid" 2>/dev/null; then
			dead=true
		else
			local i
			for ((i=timeout;i>0;i--)); do
				if ! kill -0 "$pid" 2>/dev/null; then
					dead=true
					break
				fi
				sleep 1
			done
			if ! $dead && $sigkill; then
				kill -KILL "$pid" 2>/dev/null
				sleep 1
				if ! kill -0 "$pid" 2>/dev/null; then
					dead=true
				fi
			fi
		fi
		if ! $dead; then
			return 1
		fi
	fi

	return 0
)}

# kill a pid without hassle
function sf_terminate
{
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME <pid> [pid] ..."
		return 1
	fi

	while (( $# > 0 )); do
		if
			[[ -n "${1:-}" ]] &&
			sf_integer -v -- "$1" &&
			(( $1 != 0 )) &&
			{ kill -0 "$1"; } 2>/dev/null
		then
			{ kill -TERM "$1"; wait "$1"; } 2>/dev/null || :
		fi
		shift
	done
}

# make a pidfile, or echo existing pid if any
# returns 0 if it's okay to start a new process
# (including if old pid existed and was killed)
function sf_pidfile
{
	local verbose=false
	local killtimeout=""
	local rmqueue=false
	local quiet=false
	local argv=("$@")
	local verbose=false

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":k:qQv" opt; do
		case "$opt" in
			k)
				killtimeout=$OPTARG
				if ! sf_integer -v -- "$killtimeout"; then
					return 1
				fi
			;;
			q) rmqueue=true ;;
			Q) quiet=true ;;
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <pidfile>"
		return 1
	fi

	local pid=""
	local file="${1}"
	if [[ -e "$file" ]]; then
		if ! sf_goodfile "$file"; then
			sf_println2 "Error: File \"${file}\" is no good!"
			return 1
		else
			read -r pid <"$file" 2>/dev/null || :
			if ! sf_integer -- "$pid"; then
				sf_println2 "Error: Garbage in PID file \"${file}\"!"
				return 1
			fi
			if (( pid == 0 )); then
				sf_println2 "Error: Old PID is zero! WTF?"
				return 1
			fi
			if ! kill -0 "$pid" 2>/dev/null; then
				# remove old pidfile (unable to signal pid)
				! $verbose || sf_println2 "Removing old pidfile: ${file}"
				rm "${file}"
			else
				if [[ -n "$killtimeout" ]]; then
					if sf_termkill "$pid" "$killtimeout"; then
						if sf_goodfile "$file" && ! rm "$file"; then
							sf_println2 "Error: PID file \"${file}\" is stuck!"
							return 1
						else
							! $verbose || sf_println "Old process killed - go ahead and start :)"
							sf_pidfile "${argv[@]}" && return $? || return $?
						fi
					else
						sf_println2 "Error: Old process is stubborn and refused to die!"
						return 1
					fi
				fi

				# return existing pid
				$quiet || sf_println "$pid"
				return 1
			fi
		fi
	fi
	if sf_mkfile -f "$file" >/dev/null; then
		# made new pidfile
		sf_println $$ >"$file"
		if $rmqueue; then
			sf_rm_queue "$file"
		fi
		return 0
	elif [[ -e "$file" ]]; then
		# someone else made it first
		sf_sleep 1
		read -r pid <"$file" 2>/dev/null || :
		if [[ -z "$pid" ]]; then
			sf_println2 "Error: No pid in pidfile we didn't create: ${file}"
			sf_println2 "What the heck is going on?"
		fi
		$quiet || sf_println "$pid"
		return 1
	else
		# failed to make new pidfile
		sf_println2 "Error: Unable to create pidfile: ${file}"
		return 1
	fi
}

# put spaces at the end of every line so outlook won't remove line breaks from emails
function sf_endspace { awk '{ print $0"   " }'; }

# write something on the screen while clearing the rest of it
function sf_clearwrite
{
	tput civis
	stdbuf -oL expand |
	gawk \
		-v home="$(tput cup 0 0)" \
		-v ed="$(tput ed)" \
		-v el="$(tput el)" \
		-v lines="$(tput lines)" \
		-v cols="$(tput cols)" \
		-v rst="${*:-"-- RESET --"}" \
		'
			function reset() { printf "%s",home; done=0; c=0 }
			function end() { if (done == 0 && (length(first) != cols || c != lines)) { printf "%s",ed }; done=1 }
			BEGIN { reset() }
			{
				line=$0
				if (line == rst) { end(); reset(); next }
				do
				{
					if (c == lines) { end(); next }
					if (c) { printf "\n" }
					c++
					first=substr(line,1,cols)
					line=substr(line,length(first)+1)
					printf "%s",first
					if (length(first) != cols) { printf "%s",el }
					fflush()
				} while (line)
			}
			END { end() }
		'
	tput cnorm
}

# sleep using built-in functions only
function sf_fastsleep { sf_sleep "$@"; }
function sf_sleep
{
# ORIG:
#	coproc sleep { exec >&-; read -t "$1"; }; exec {sleep[0]}<&-; wait $sleep_PID
# V1:
#	local fd
#	exec {fd}<> >(:)
#	read -r ${1:+-t "$1"} -u $fd || :
#	exec {fd}>&-
# V2:
#	local IFS
#	[[ -n "${_sf_sleep_fd:-}" ]] || exec {_sf_sleep_fd}<> <(:)
#	read -r ${1:+-t "$1"} -u $_sf_sleep_fd || :
# V3 (MacOS workaround):
	local IFS
	[[ -n "${_sf_sleep_fd:-}" ]] || { exec {_sf_sleep_fd}<> <(:); } 2>/dev/null ||
	{
		local fifo
		fifo=$(mktemp -u)
		mkfifo -m 700 "$fifo"
		exec {_sf_sleep_fd}<>"$fifo"
		rm "$fifo"
	}
	read -r ${1:+-t "$1"} -u $_sf_sleep_fd || :
}

# sleep in one second intervals (wildly inaccurate, but reacts faster to kills)
function sf_sleep_1
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <integer>"
		return 1
	fi

	local delay=$1
	if ! sf_integer -v -- "$delay"; then
		return 1
	fi

	local i
	for(( i=0; i<delay; i++ )); do
		sf_sleep 1 || return $?
	done
}

# sleep until N seconds has passed between two calls to the function
function sf_sleepmore
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <integer>"
		return 1
	fi

	local delay=$1
	if ! sf_integer -v -- "$delay"; then
		return 1
	fi

	local sleeptime
	sleeptime=$(( ${_sf_sleepmoreseconds:=$SECONDS} - SECONDS ))
	if (( sleeptime <= 0 )); then
		_sf_sleepmoreseconds=$SECONDS
	else
		sf_sleep "$sleeptime"
	fi
	(( _sf_sleepmoreseconds += delay ))
}

# reset sleepmore (something likely failed and we want to run again immediately)
function sf_sleepreset { unset _sf_sleepmoreseconds; }

# get a hash of the contents of a directory
function sf_dirhash
{	
	local dir=$1
	if ! type sha256sum >/dev/null 2>&1; then
		sf_println2 "${FUNCNAME}: Required command \`sha256sum\` is missing!"
		return 1
	fi
	(
		cd "$dir" || exit 1
		{
			find . -mindepth 1 ! -type f -print0
			find . -mindepth 1 ! -type d -print0 | xargs -r -0 sha256sum
		} | sha256sum | cut -d ' ' -f 1 | grep "^"
	)
}

# get the hostname
function sf_hostname
{(
	local full=false
	local domain=false

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":fd" opt; do
		case "$opt" in
			f) full=true ;;
			d) domain=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	if (( $# != 0 )); then
		sf_println2 "Usage: $FUNCNAME [-f]"
		return 1
	fi

	exec 2>/dev/null

	if $full; then
		hostname -f
	elif $domain; then
		hostname -d
	else
		hostname -s
	fi
)}

# simple URL encoding - just encode everything
function sf_urlencode
{
	local text="$*"
	if ! (( $# )); then
		text=$(cat)
	fi
	local encoded
	encoded=$(xxd -plain <<<"$text" | tr -d '\n' | sed 's/\(..\)/%\1/g')
	sf_println "${encoded%\%0a}"
}

# get a value from the query string global
function sf_query
{
	local empty=false
	local base64=false
	local lower=false
	local null=false
	local decode=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":bdelu" opt; do
		case "$opt" in
			b) base64=true ;;
			d) decode=true ;;
			e) empty=true ;;
			l) lower=true ;;
			u) null=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <key>"
		return 1
	fi

	local key=${1,,}

	while IFS='=' read -r -d '&' ikey value; do
		[[ "${ikey,,}" = "$key" ]] || continue
		$empty || [[ -n "$value" ]] || return 1
		! $base64 || value=$(sf_web64decode <<<"$value")
		! $decode || value=$(sf_urldecode "$value")
		! $lower || value=${value,,}
		sf_println "$value"
		return 0
	done <<<"${QUERY_STRING:+"${QUERY_STRING}&"}"
	
	if $null; then
		sf_println
		return 0
	fi

	return 1
}

# hostname in tolower
function sf_hostname_lower { sf_hostname "$@" | sf_tolower; }

# check if the user can interact
function sf_terminal
{
	if (( $# != 0 )); then
		sf_println2 "Usage: $FUNCNAME"
		return 1
	fi

	if ! [[ -t 0 ]] 2>/dev/null; then
		return 1
	fi

	return 0
}

# track timers
function sf_timer
{
	local check=false
	local reset=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":cr" opt; do
		case "$opt" in
			c) check=true ;;
			r) reset=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi


	if (( $# != 2 )); then
		sf_println2 "Usage: $FUNCNAME <name> <seconds>"
		return 1
	fi

	local name=$1
	local seconds=$2

	if [[ -z "$name" ]]; then
		sf_println2 "Error: $FUNCNAME: Invalid timer name"
		return 1
	fi

	if ! sf_integer -v -- "$seconds"; then
		return 1
	fi

	if ! declare -p _sf_timers >/dev/null 2>&1; then
		declare -gA _sf_timers
	fi

	local t now
	t="${_sf_timers["$name"]:-}"
	now=$(sf_unixtime)

	if (( t <= now )) || $reset; then
		$check || _sf_timers["$name"]=$((now+seconds))
		return 0
	else
		return 1
	fi
}

# check if a short option is set
function sf_isset
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <option>"
		return 1
	fi

	if [[ "$-" = *"$1"* ]]; then
		return 1
	fi

	return 0
}

# attempt to mimic the effect of "nohup"
function sf_nohup
{
	local append=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":a" opt; do
		case "$opt" in
			a) append=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <outputfile>"
		return 1
	fi

	if [[ -e "$1" ]]; then
		if [[ "$(sf_fullpath "$1")" != "/dev/null" ]] && ! sf_goodfile -w "$1"; then
			sf_println2 "Error: Unable to write to output file \"${1}\"!"
			return 1
		fi
	elif ! sf_gooddir -w "$(dirname "$1")"; then
		sf_println2 "Error: No write access to \"$(dirname "${1}")\"!"
		return 1
	fi

	# close stdin, and make any read attempt an error
	if [[ -t 0 ]]; then
		exec 0<&- # 0</dev/null
	fi

	# redirect stdout to a file if it's a TTY
	if [[ -t 1 ]]; then
		if $append; then
			exec 1>>"$1"
		else
			exec 1>"$1"
		fi
	fi

	# redirect stderr to stdout if it's a TTY
	if [[ -t 2 ]]; then
		exec 2>&1
	fi

	# trap the HUP signal to ignore it
	trap : HUP
}

# check if a user exists on this system
function sf_hosthasuser
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <user>"
		return 1
	fi

	local line
	line=$(sf_passwdline "$1") || :

	if [[ -z "$line" ]]; then
		return 1
	fi

	cut -d: -f 3 <<<"$line"

	return 0
}

# get the parent pid of current or given pid
function sf_ppid
{
	if (( $# > 1 )) || ! sf_integer -v "${1:-$$}"; then
		return 1
	fi
	ps -p "${1:-$$}" -o ppid=
}

# test a file's integrity
function sf_verifydata
{
	if (( $# < 2 )); then
		sf_println2 "Usage: $FUNCNAME <format> <file> [part] ..."
		return 1
	fi
	format=$1
	shift
	local cmd
	case "$format" in
		tgz) cmd="tar zxOf -" ;;
		gz) cmd="gunzip" ;;
		*)
			sf_println2 "Error: Unknown format: $format"
			return 1
		;;
	esac

	local file total_size=0
	for file in "$@"; do
		sf_println "Testing $file ..."
		if ! sf_goodfile -v "$file" >/dev/null; then
			return 1
		fi
		local size
		size=$(sf_size "$file")
		(( total_size += size ))
		if (( size == 0 )); then
			sf_println2 "Error: $1 has a size of 0!"
			return 1
		fi
	done
	if (($# > 1)); then
		sf_println "Testing joined file integrity"
	fi
	if ! cat "$@" | $cmd &>/dev/null; then
		sf_println2 "Error: Error while verifying file contents"
		sf_println2 "File integrity compromized!"
		return 1
	fi
	if (($# == 1)); then
		sf_println "$1 is OK - $total_size bytes"
	else
		sf_println "Files are OK - $total_size bytes"
	fi
}

# test a tar.gz file's integrity
function sf_tgztest { sf_verifydata "tgz" "$@"; }

# split files in gigabyte size chunks
function sf_gigsplit
{
	local dir name
	dir=$(dirname "$*")
	name="$(basename "$*")_"
	find "$dir" -mindepth 1 -maxdepth 1 -type f -name "${name}*" -delete
	split -d -a 4 -b 1073741824 - "${dir}/${name}"
}

# check if a group exists on this system
function sf_hosthasgroup
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <group>"
		return 1
	fi

	(
		set -o pipefail
		getent group "$1" | cut -d: -f3
	)
}

# rudimentary job management
_sf_job_i=0
_sf_job_lock=""
declare -A _sf_jobs=()
function sf_job_init
{
	if [[ -n "$_sf_job_lock" ]]; then
		sf_println2 "$FUNCNAME: Already initialized!"
		return 1
	fi
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <lockfile>"
		return 1
	fi
	if ! sf_goodfile -qvw -- "$1"; then
		return 1
	fi
	_sf_job_lock=$1
	function _sf_job_tput
	{(
		if ! tput sgr0 >/dev/null 2>&1; then
			export TERM="ansi"
		fi
		tput "$@"
	)}
	_sf_job_color_reset="$(_sf_job_tput sgr0)"
	_sf_job_color_green="${_sf_job_color_reset}$(tput setaf 2)"
	_sf_job_color_orange="${_sf_job_color_reset}$(tput setaf 3)"
	_sf_job_color_magenta="${_sf_job_color_reset}$(tput setaf 5)"
	_sf_job_color_cyan="${_sf_job_color_reset}$(tput setaf 6)"
	_sf_job_color_red="${_sf_job_color_reset}$(tput bold)$(tput setaf 1)"
	_sf_job_color_light_blue="${_sf_job_color_reset}$(tput bold)$(tput setaf 4)"
	unset -f _sf_job_tput
	sf_job_log "Cathedral Job Management Initiated"
}
function sf_job_log { local fd; exec {fd}>>"$_sf_job_lock"; flock "$fd"; sf_println "$*"; flock -u "$fd"; }
function sf_job_log_step  { sf_job_log "${_sf_job_color_cyan}==> ${_sf_job_color_light_blue}$*${_sf_job__sf_job_color_reset}"; }
function sf_job_log_yell  { sf_job_log "${_sf_job_color_magenta}$*${_sf_job_color_reset}"; }
function sf_job_log_good  { sf_job_log "${_sf_job_color_green}$*${_sf_job_color_reset}"; }
function sf_job_log_bad { sf_job_log "${_sf_job_color_red}$*${_sf_job_color_reset}" >&2; }
function sf_job
{
	if [[ -z "$_sf_job_lock" ]]; then
		sf_println2 "$FUNCNAME: Run sf_job_init first!"
		return 1
	fi
	sf_job_i "$@" </dev/null
}
function sf_job_i
{
	if [[ -z "$_sf_job_lock" ]]; then
		sf_println2 "$FUNCNAME: Run sf_job_init first!"
		return 1
	fi
	local job=( "$@" )
	local job_id="$((_sf_job_i++))"
	local job_desc="${job_name}: ${job[*]}"
	local job_name input
	job_name="$(printf 'Job %2d' "$job_id")"
	input="$(base64 -w0)"
	[[ -z "$input" ]] || job_desc+=" (STDIN)"
	function _sf_job_output
	{
		local line
		while IFS= read -r line; do
			[[ "$line" =~ [^[:space:]]+ ]] || continue
			sf_job_log "${_sf_job_color_orange}${job_name}:${_sf_job_color_reset} $line"
		done
	}
	sf_job_log "${_sf_job_color_orange}${job_desc}${_sf_job_color_reset}"
	(
		pid=$BASHPID usr1=false usr2=false
		trap 'usr1=true' USR1
		trap 'usr2=true' USR2
		"${job[@]}" \
			0< <(base64 -d <<<"$input") \
			1> >(_sf_job_output >&1; kill -USR1 "$pid") \
			2> >(_sf_job_output >&2; kill -USR2 "$pid") \
			& pid=$!
		while ! $usr1 || ! $usr2 || kill -0 "$pid" 2>/dev/null; do
			sf_sleep 0.1
		done
		wait "$pid" && code=$? || code=$?
		exit "$code"
	) &
	_sf_jobs[$!]="$job_desc"
	unset -f _sf_job_output
}
function sf_job_wait
{
	if [[ -z "$_sf_job_lock" ]]; then
		sf_println2 "$FUNCNAME: Run sf_job_init first!"
		return 1
	fi
	local stop_on_error=false next_only=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":en" opt; do
		case "$opt" in
			e) stop_on_error=true ;;
			n) next_only=true ;;
			[?])
				sf_error_unknown_option
				exit 1
			;;
			:)
				sf_error_missing_argument
				exit 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	local pid code count=0
	while (( ${#_sf_jobs[@]} )); do
		if (( ${#_sf_jobs[@]} != count )); then
			count=${#_sf_jobs[@]}
			sf_job_log_yell "Running jobs: $count"
		fi
		for pid in "${!_sf_jobs[@]}"; do
			if ! kill -0 "$pid" 2>/dev/null; then
				wait "$pid" && code=$? || code=$?
				if (( code )); then
					sf_job_log_bad "FAILED ${_sf_jobs["$pid"]}"
					! $stop_on_error || return "$code"
				else
					sf_job_log_good "SUCCESS ${_sf_jobs["$pid"]}"
				fi
				unset _sf_jobs["$pid"]
				! $next_only || return "$code"
			fi
			sf_sleep 0.1
		done
	done
}

# run commands silently, but output the result if it's bad
# optionally pass through fd1 or fd2
function sf_silence
{
	local quote=false
	local silence_fd1=false silence_fd2=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":12p" opt; do
		case "$opt" in
			1) silence_fd1=true ;;
			2) silence_fd2=true ;;
			p) quote=true ;;
			[?])
				sf_error_unknown_option
				exit 1
			;;
			:)
				sf_error_missing_argument
				exit 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	if ! $silence_fd1 && ! $silence_fd2; then
		silence_fd1=true
		silence_fd2=true
	fi
	! $quote || sf_quote "$@"
	local code=0 out
	if ! $silence_fd1; then
		local fd1
		exec {fd1}>&1
	fi
	out="$(
		set -o pipefail
		{
			if $silence_fd2; then
				exec 2>&1
			fi
			if ! $silence_fd1; then
				exec >&${fd1}
			fi
			"$@"
		} | base64 -w0
	)" || code=$?
	if ! $silence_fd1; then
		exec {fd1}>&-
	fi
	! (( code )) || base64 -d <<<"$out" >&2
	return "$code"
}	 

# run the timeout command without job control feedback to stderr
function sf_timeout
{
	local fd code
	exec {fd}>&2
	{ timeout "$@" 2>&$fd; } 2>/dev/null && code=$? || code=$?
	exec 2>&$fd
	exec {fd}>&-
	return "$code"
}

# check if a file is good for reading
function sf_goodfile
{
	local code=0
	sf_timeout -s9 30 /usr/bin/env bash -s -- "${BASH_SOURCE[0]}" "$FUNCNAME" "$@" <<-"EOF" || code=$?
		set -e
		set -u

		source "$1"
		func="$2"
		shift 2

		executable=false
		writable=false
		quiet=false
		fifo=false
		verbose=false
		while getopts ":fqsvwx" opt; do
			case "$opt" in
				f) fifo=true ;;
				q|s) quiet=true ;;
				v) verbose=true ;;
				w) writable=true ;;
				x) executable=true ;;
				[?])
					sf_error_unknown_option
					exit 1
				;;
				:)
					sf_error_missing_argument
					exit 1
				;;
			esac
		done
		shift $((OPTIND-1))
		if [[ "${1:-}" = "--" ]]; then shift; fi

		if (( $# != 1 )); then
			sf_println2 "Usage: $func [-v] [-w] [-x] <file>"
			exit 1
		fi
		
		file="$1"
		if [[ -h "$file" ]]; then
			file=$(readlink -f -n "$file")
			! $verbose || sf_println "\"$1\" is a symlink pointing to \"$file\""
		fi

		if ! [[ -e "$file" ]]; then
			! $verbose || sf_println2 "File \"$file\" does not exist!"
			exit 1
		fi

		if ! $fifo; then
			if ! [[ -f "$file" ]]; then
				! $verbose || sf_println2 "File \"$file\" is not a regular file!"
				exit 1
			fi
		else
			if ! [[ -p "$file" ]]; then
				! $verbose || sf_println2 "File \"$file\" is not a FIFO!"
				exit 1
			fi
		fi

		if ! [[ -r "$file" ]]; then
			! $verbose || sf_println2 "File \"$file\" is not readable!"
			exit 1
		fi

		if $writable && ! [[ -w "$file" ]]; then
			! $verbose || sf_println2 "File \"$file\" is not writable!"
			exit 1
		fi

		if $executable && ! [[ -x "$file" ]]; then
			! $verbose || sf_println2 "File \"$file\" is not executable!"
			exit 1
		fi

		$quiet || ! $verbose || sf_println "File \"$file\" is good."
		exit 0
	EOF
	if (( code != 0 )); then
		if (( code > 128 )); then
			sf_println2 "Error: Timeout running \`$FUNCNAME $*\`: Stuck file system?"
		fi
		return "$code"
	fi
}

# check if a file is empty
function sf_isemptyfile
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME </path>"
		return 1
	fi
	if ! sf_goodfile "$1"; then
		return 1
	fi
	if (($(sf_wc -c <"$1"))); then
		return 1
	fi
	return 0
}

# check if a directory is any good
function sf_gooddir
{
	local code=0
	sf_timeout -s9 30 /usr/bin/env bash -s -- "${BASH_SOURCE[0]}" "$FUNCNAME" "$@" <<-"EOF" || code=$?
		set -e
		set -u

		source "$1"
		func="$2"
		shift 2

		verbose=false
		writable=false
		quiet=false
		checkls=false
		executable=true # default true for directories, no way to override this for now
		while getopts ":qslvwx" opt; do
			case "$opt" in
				q|s) quiet=true ;;
				l) checkls=true ;;
				v) verbose=true ;;
				w) writable=true ;;
				x) executable=true ;;
				[?])
					sf_error_unknown_option
					exit 1
				;;
				:)
					sf_error_missing_argument
					exit 1
				;;
			esac
		done
		shift $((OPTIND-1))
		if [[ "${1:-}" = "--" ]]; then shift; fi

		if (( $# != 1 )); then
			sf_println2 "Usage: $func [-v] [-w] [-x] <dir>"
			exit 1
		fi
		
		dir="$1"
		if [[ -h "$dir" ]]; then
			dir=$(readlink -f -n "$dir")
			! $verbose || sf_println2 "\"$1\" is a symlink pointing to \"$dir\""
		fi

		if ! [[ -e "$dir" ]]; then
			! $verbose || sf_println2 "Directory \"$dir\" does not exist!"
			exit 1
		fi

		if ! [[ -d "$dir" ]]; then
			! $verbose || sf_println2 "Directory \"$dir\" is not a directory!"
			exit 1
		fi

		if ! [[ -r "$dir" ]]; then
			! $verbose || sf_println2 "Directory \"$dir\" is not readable!"
			exit 1
		fi

		if $writable && ! [[ -w "$dir" ]]; then
			! $verbose || sf_println2 "Directory \"$dir\" is not writable!"
			exit 1
		fi

		if $executable && ! [[ -x "$dir" ]]; then
			! $verbose || sf_println2 "Directory \"$dir\" is not executable!"
			exit 1
		fi

		if $checkls && ! sf_timeout -s9 25 ls "$dir" >/dev/null 2>&1; then
			! $verbose || sf_println2 "Directory \"$dir\" could not be listed!"
			exit 1
		fi

		$quiet || ! $verbose || sf_println "Directory \"$dir\" is good."
		exit 0
	EOF
	if (( code != 0 )); then
		if (( code > 128 )); then
			sf_println2 "Error: Timeout running \`$FUNCNAME $*\`: Stuck file system?"
		fi
		return "$code"
	fi
}

# min
function sf_math_min
{
	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <integer> [integer] ..."
		return 1
	fi
	local min=$1
	shift
	while (($# != 0)); do
		if (($1 < min)); then
			min=$1
		fi
		shift
	done
	sf_println "$min"
}

# max
function sf_math_max
{
	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <integer> [integer] ..."
		return 1
	fi
	local max=$1
	shift
	while (($# != 0)); do
		if (($1 > max)); then
			max=$1
		fi
		shift
	done
	sf_println "$max"
}

# limit
function sf_math_limit
{
	if (( $# != 3 )); then
		sf_println2 "Usage: $FUNCNAME <integer> <min> <max>"
		return 1
	fi
	sf_math_max "$2" "$(sf_math_min "$1" "$3")"
}

# get current username
function sf_user
{
	if (( $# != 0 )); then
		sf_println2 "Usage: $FUNCNAME"
		return 1
	fi

	sf_println "${USER:-$(whoami)}"
}

# try to sanitize http lines
function sf_web2sane
{
	local line filter=false printable=false utf8line
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":fp" opt; do
		case "$opt" in
			f) filter=true ;;
			p) printable=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	if ! sf_type -v "recode" >/dev/null; then
		exit 1
	fi
	while IFS='' read -r line; do
		if
			! recode utf8..h <<<"$line" >/dev/null 2>&1 &&
			utf8line=$(recode "iso8859-15..utf8" <<<"$line") &&
			[[ -n "$utf8line" ]]
		then
			line=$utf8line
		fi
		line=$(recode "utf8..h" <<<"$line" | sed -e 's/&amp;/\&/g' | recode "h..utf8")
		if $filter; then
			line=$(recode -f "utf8..iso8859-15" <<<"$line" | recode "iso8859-15..utf8")
		fi
		if $printable; then
			line=$(sf_printable <<<"$line")
		fi
		sf_println "$line"
	done
}

# remove newlines
function sf_oneline
{
	local escape=false
	local separator=" "
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":es:" opt; do
		case "$opt" in
			e) escape=true ;;
			s) separator=$OPTARG ;;
			[?])
				sf_println2 "Unknown option -${OPTARG}"
				return 1
			;;
			:)	
				sf_println2 "Option -${OPTARG} requires an argument"
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	local first=true line
	while read -r line; do
		[[ -n "$line" ]] || continue
		$first && first=false || sf_print "$separator"
		if $escape; then
			sf_print "$line" | sed -e 's/\([^[:alnum:]]\)/\\\1/g'
		else
			sf_print "$line"
		fi
	done
	sf_println
}

# do something until it works
function sf_force
{
	if [[ -z "${*:-}" ]]; then
		sf_println2 "Usage: $FUNCNAME [-d <delay>] [-l <limit>] <cmd>"
		return 1
	fi
	local delay=0
	local limit=0
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":d:l:" opt; do
		case "$opt" in
			d)
				delay=$OPTARG
				if ! sf_number -v -- "$delay"; then
					return 1
				fi
			;;
			l)
				limit=$OPTARG
				if ! sf_integer -v -- "$limit"; then
					return 1
				fi
			;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	local code
	while true; do
		"$@" && break || code=$?
		if (( limit )) && ! (( --limit )); then
			return $code
		fi
		sleep "$delay" || return $?
	done
}
function sf_force1
{
	if [[ -z "${*:-}" ]]; then
		sf_println2 "Usage: $FUNCNAME <cmd>"
		return 1
	fi
	while ! "$@"; do sleep 1; done
}

# generate a random password
function sf_randpass
{
	local alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
	local alnum="${alpha}0123456789"
	local special='!"#%&,.-;:_()=?@€$£{[]}'
	local chars=$alnum
	local count=8
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":ac:s" opt; do
		case "$opt" in
			c)
				sf_integer -v -- "$OPTARG" >/dev/null || return 1
				count=$OPTARG
			;;
			s) chars="${alnum}${special}" ;;
			a) chars=$alpha ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	local div="${#chars}" pass="" i
	for ((i=0; i<count; i++)); do
		pass+="${chars:$((RANDOM%div)):1}"
	done
	sf_println "$pass"
}

# generate a fake random uuid
function sf_fakeuuid
{
	printf \
		'%x%x%x%x%x%x%x%x-%x%x%x%x-%x%x%x%x-%x%x%x%x-%x%x%x%x%x%x%x%x%x%x%x%x\n' \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16)) \
		$((RANDOM%16))
}

# encode and decode base64 with web replacements
function sf_web64
{
	local s
	(( $# )) && s="$1" || s="$(cat)"
	s="$(base64 <<<"$s")"
	s="${s//\//_}"
	s="${s//+/-}"
	sf_println "$s"
}
function sf_web64decode
{
	local s pad i
	(( $# )) && s="$1" || s="$(cat)"
	pad=$(( (4 - ${#s} % 4) % 4 ))
	for (( i=0; i<pad; i++ )); do s+='='; done
	s="${s//_/\/}"
	s="${s//-/+}"
	base64 -d <<<"$s"
}

# decode query strings
function sf_urldecode { : "${*//+/ }"; printf '%b\n' "${_//%/\\x}"; }

# find mounts at or below the given path
function sf_mounts
{
	local reverse=""
	local fstab=""
	local exact=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":frx" opt; do
		case "$opt" in
			f) fstab="--fstab" ;;
			r) reverse="-r" ;;
			x) exact=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# > 1 )); then
		sf_println2 "Usage: $FUNCNAME [/path]"
		return 1
	fi

	local root=${1:-}
	local slash
	slash=$(sf_slashpath "$root")
	
	if [[ "$slash" != "/"* ]]; then
		sf_println2 "Error: Path must start with a slash"
		return 1
	fi

	{
		local line
		while read -r line; do
			if [[ "$line" = "$root" ]] || { ! $exact && [[ "$line" = "$slash"* ]]; }; then
				sf_println "$line"
			fi
		done < <(findmnt --raw --output=target --noheadings $fstab)
	} | sort $reverse | grep .
}

# check if something is mounted here
function sf_ismounted
{
	local check=false check_bind=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":c" opt; do
		case "$opt" in
			c) check=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME [-c] </path>"
		return 1
	fi

	local path=$1

	case "$path" in
		/*) ;;
		*)
			sf_println2 "Error: Path must start with a slash"
			return 1
		;;
	esac

	while [[ "$path" = "/"*"/" ]]; do
		path=${path%"/"}
	done

	grep -q "^${path}$" < <(sf_mounts) || return $?

	if $check; then
		sf_gooddir -xl "$path" &&
		grep -q "^${path}$" < <(sf_mounts) ||
		return $?

		# special case for bind mounts, verify contents in source dir vs target dir
		local opt src
		opt=$(findmnt --raw --noheadings --fstab --target="$path" --output=options)
		src=$(findmnt --raw --noheadings --fstab --target="$path" --output=source)
		if [[ ",${opt}," = *",bind,"* ]] || [[ "$src" = "bindfs#"* ]]; then
			local src
			src=$(findmnt --raw --noheadings --fstab --target="$path" --output=source)
			if sf_isemptydir "$src"; then
				sf_isemptydir "$path" || return 1
			else
				! sf_isemptydir "$path" || return 1
			fi
		fi
	fi
}

# get os version
function sf_sysver
{
	if (( $# )); then
		local sysver
		sysver="$(sf_sysver)"
		while (( $# )); do
			! [[ " ${sysver,,} " = *" ${1,,} "* ]] || return 0
			shift
		done
		return 1
	fi
	local os
	os=$(uname -s)
	case "$os" in
		Linux)
			local issue=""
			if sf_goodfile "/etc/issue.net"; then
				read -r issue <"/etc/issue.net" || :
				read -r issue <<<"$issue"
			fi
			if [[ -z "$issue" ]] || [[ "$issue" = '\S' ]]; then
				if sf_goodfile "/etc/redhat-version" || sf_goodfile "/etc/redhat-release"; then
					issue="RedHat"
				elif sf_goodfile "/etc/arch-release"; then
					issue="Arch Linux"
				elif sf_goodfile "/etc/centos-release"; then
					issue="CentOS"
				fi
			fi
			sf_println "${os}${issue:+" ${issue%% \\*}"}"
		;;
		FreeBSD)
			local version
			version=$(uname -r)
			sf_println "${os} ${version}"
		;;
		*)
			sf_println "${os}"
		;;
	esac
}

# attempt to read a boolean string
function sf_str2bool
{
	case "${@,,}" in
		1|true|yes|on|enable|enabled)
			return 0
		;;
		*)
			return 1
		;;
	esac
}

# put a string in lowercase
function sf_tolower
{
	if (( $# == 0 )); then
		cat | tr '[:upper:]' '[:lower:]'
	else
		sf_println "${@,,}"
	fi
}

# put a string in uppercase
function sf_toupper
{
	if (( $# == 0 )); then
		cat | tr '[:lower:]' '[:upper:]'
	else
		tr '[:lower:]' '[:upper:]' <<<"$@"
	fi
}

# wc guaranteed to not have spaces around it
function sf_wc
{
	wc "$@" | sf_trim
}

# check if any data is returned
function sf_any { grep -q '^'; }

# get the passwd line of a user
function sf_passwdline
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME [user]"
		return 1
	fi
	
	local user=$1 ent
	if
		{ ent=$(getent passwd "$1" 2>/dev/null) && [[ -n "${ent:-}" ]]; } ||
		{ ent=$(grep ^"$user": <"/etc/passwd" 2>/dev/null) && [[ -n "${ent:-}" ]]; }
	then
		sf_println "$ent"
		return 0
	fi
	return 1
}

# get the home directory of a user
function sf_home
{
	if (( $# > 1 )); then
		sf_println2 "Usage: $FUNCNAME [user]"
		return 1
	fi

	local user=${1:-$(sf_user)}
	local home
	home=$(sf_passwdline "$user" | cut -d: -f 6)

	if [[ -z "$home" ]] && (( $# == 0 )) && [[ -n "${HOME:-}" ]]; then
		sf_println "$HOME"
		return 0
	fi

	if [[ -z "$home" ]]; then
		sf_println2 "Error: $FUNCNAME: unable to determine the home directory of \"$user\""
		return 1
	fi
	
	sf_println "$home"
	return 0
}

# get temp dir
function sf_tmpdir
{(
	set -e
	set -u

	if
		[ -f "/cathedral/src/tmpenv" ] &&
		[ -r "/cathedral/src/tmpenv" ]
	then
		source /cathedral/src/tmpenv
	fi

	if (( $# != 0 )); then
		sf_println2 "Usage: $FUNCNAME"
		return 1
	fi

	sf_println "${TMP:-"/tmp"}"
)}

# check if a package is installed (expand to support more systems)
function sf_hosthaspackage
{(
	set -e
	set -u

	local verbose=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":v" opt; do
		case "$opt" in
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME [-v] <package> [package] ..."
		return 1
	fi

	local result=0
	while [[ -n "${1:-}" ]]; do
		case "$(sf_sysver)" in
			*Debian*|*Ubuntu*|*BackTrack*|*Kali*|*Raspbian*)
				if ! dpkg -l "${1}" 2>/dev/null | grep -q ^.i; then
					result=1
					! $verbose || sf_println2 "Warning: Package \"${1}\" is not installed!"
				fi
			;;
			*Arch*)
				if ! pacman -Qq | grep -q "^${1}"; then
					result=1
					! $verbose || sf_println2 "Warning: Package \"${1}\" is not installed!"
				fi
			;;
			*CentOS*)
				if ! yum list "${1}" 2>/dev/null | grep -q " installed$"; then
					result=1
					! $verbose || sf_println2 "Warning: Package \"${1}\" is not installed!"
				fi
			;;
			FreeBSD*)
				case "$1" in
					cron|at)
						: # these packages are part of the FreeBSD standard system
					;;
					*)
						if ! pkg_version -s "${1}" 2>/dev/null | grep -q "^${1} "; then
							result=1
							! $verbose || sf_println2 "Warning: Package \"${1}\" is not installed!"
						fi
					;;
				esac
			;;
			*)
				sf_println2 "Error: Unable to check for installed packages - \"$(sf_sysver)\" is unsupported!"
				result=1
				break
			;;
		esac
		shift
	done

	return $result
)}

# install new package (expand to support more systems)
function sf_installpackage
{
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME <package> [package] ..."
		return 1
	fi

	case "$(sf_sysver)" in
		*Debian*|*Ubuntu*|*Raspbian*)
			aptitude install "$@"
		;;
		FreeBSD*)
			pkg_add -r "$@"
		;;
		*)
			sf_println2 "Error: Unable to install packages - \"$(sf_sysver)\" is unsupported!"
			return 1
		;;
	esac
}

# ask a yes/no question
function sf_question
{(
	local prenewline=true postnewline=true defaultyes=false answer
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":nNy" opt; do
		case "$opt" in
			n) prenewline=false; postnewline=false ;;
			N) prenewline=false ;;
			y) defaultyes=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME [-n|-N] [-y] <question>"
		return 1
	fi

	! $prenewline || sf_println2 # empty line
	if $defaultyes; then
		read -rp "${1} [Y/n] " answer
	else
		read -rp "${1} [y/N] " answer
	fi
	! $postnewline || sf_println2 # empty line
	case "$(sf_tolower "${answer:-}")" in
		y|yes)
			return 0
		;;
		n|no)
			return 1
		;;
		*)
			if $defaultyes; then
				return 0
			else
				return 1
			fi
		;;
	esac
)}

# run your default editor
function sf_edit
{
	if sf_type "sensible-editor"; then
		sensible-editor "$@"
	else
		"${EDITOR:-vim}" "$@"
	fi
}

# require certain commands in order to run
function sf_require
{
	local ok=true
	for cmd; do
		if ! type -- "$cmd" >/dev/null 2>&1; then
			sf_println2 "Error: Required command '$cmd' was not found on this system!"
			ok=false
		fi
	done
	if ! $ok; then
		return 127
	fi
}

# check if commands are available
function sf_type
{(
	local verbose=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":v" opt; do
		case "$opt" in
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME [-v] <command> [command] ..."
		return 1
	fi
	while [[ -n "${1:-}" ]]; do
		if ! type -- "$1" >/dev/null 2>&1; then
			! $verbose || sf_println2 "Error: \"$1\" is not a valid command"
			return 1
		fi
		shift
	done
	return 0
)}

# check if a variable is an integer
function sf_integer { sf_number -i "$@"; }

# check if a variable is a decimal (accepts "1", "1.0", "1." and ".1")
function sf_decimal { sf_number "$@"; }

# check if a variable is a valid number
function sf_number
{
	local decimal=true
	local negative=false
	local complain=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":cC:de:int:vq" opt; do
		case "$opt" in
			i) decimal=false ;;
			n) negative=true ;;
			v) complain=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
			*) sf_println2 "Warning: Deprecated option passed to ${FUNCNAME}: $opt" ;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	local regex=""
	if $negative; then
		regex='-?'
	fi
	if $decimal; then
		regex='^('"$regex"'[[:digit:]]+(\.[[:digit:]]*)?|'"$regex"'\.[[:digit:]]+)$'
	else
		regex='^'"$regex"'[[:digit:]]+$'
	fi
	if [[ "$*" =~ $regex ]]; then
		return 0
	fi
	if $complain; then
		local error
		case "${FUNCNAME[1]}" in
			sf_integer) printf '`%s` is not a valid integer!\n' "$*" >&2 ;;
			sf_decimal) printf '`%s` is not a valid decimal!\n' "$*" >&2 ;;
			*) printf '`%s` is not a valid number!\n' "$*" >&2 ;;
		esac
	fi
	return 1
}

# append a slash to a path if none is there
function sf_slashpath
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <path>"
		return 1
	fi

	local path=${1}
	[[ "$path" = *"/" ]] || path="${path}/"
#	case "$path" in */) ;; *) path="${path}/" ;; esac

	sf_println "${path}"
}

# append a dash to a string if none is there
function sf_dashstring
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <string>"
		return 1
	fi

	local string=${1}
	[[ $string = *"-" ]] || string="${string}-"
#	case "$string" in *-) ;; *) string="${string}-" ;; esac

	sf_println "${string}"
}

# determine if a user is in a given group
function sf_ingroup
{
	if (( $# < 1 )); then
		sf_println2 "Usage: $FUNCNAME <group> [group] ..."
		return 1
	fi

	local i
	local group
	for (( i=1; i<=$#; i++ )); do
		for group in $(groups); do
			if [[ "$group" = "${!i}" ]]; then
				return 0
			fi
		done
	done
	return 1
}

# carriage return, line feed
function sf_crlf
{
	if (( $# )); then
		sf_crlf <<<"$@"
		return $?
	fi
	perl -e '
		$| = 1;
		while ((my $c = getc) ne undef)
		{
			if ("$c" eq "\r") { next; }
			if ("$c" eq "\n") { print "\r\n"; next; }
			print "$c";
		}
	'
}

# filter out escape sequences, such as colors
function sf_filter_escape
{
	if (( $# )); then
		sf_filter_escape <<<"$@"
		return $?
	fi
	perl -pe 's/\e[^[:alpha:]]+[[:alpha:]]//g'
}

# filter out any non-printable characters
function sf_printable
{
	if (( $# )); then
		printf '%s' "$*" | sf_printable
	else
		sed -e 's/[^[:print:]]//g'
	fi
}

# filter out color codes
function sf_filter_colors
{
	if (( $# )); then
		printf '%s' "$*" | sf_filter_colors
	else
		sed -e 's/\x1B\[[0-9;]\+[A-Za-z]//g'
	fi
}

# set up basic functions for telnet handling (use with tcpserver or similar)
function sf_tn_init
{
	_sf_tn_mode=${1:-"default"}

	local cmd
	for cmd in iconv perl pv stdbuf xxd; do
		if ! type "$cmd" >/dev/null 2>&1; then
			sf_println2 "Error: ${FUNCNAME}: Required command not found: \`${cmd}\`"
			return 1
		fi
	done

	exec {_sf_tn_raw_fd}>&1
	exec > >( { sf_crlf; } 2>/dev/null )
	function echo { { builtin echo "$@"; } 2>/dev/null; }
	function println { { builtin printf '%s\r\n' "$*" >&${_sf_tn_raw_fd}; } 2>/dev/null; }
	function tn_raw { { builtin printf '%s' "$*" >&${_sf_tn_raw_fd}; } 2>/dev/null; }
	function read { { builtin read -r "$@"; } 2>/dev/null; }
	function printf { { builtin printf "$@"; } 2>/dev/null; }
	function cat { { command cat "$@"; } 2>/dev/null; }
	function pv { { command pv "$@"; } 2>/dev/null; }
	function xxd { { command xxd "$@"; } 2>/dev/null; }

	function _sf_tn_autostar
	{
		local _text="$*"
		if $__password; then
			_text=$(_sf_tn_iconv "$_text" | sed -e 's/./*/g')
		fi
		tn_raw "$_text"
	}

	function _sf_tn_iconv
	{
		{
			if (( $# )); then
				printf '%s' "$*"
			else
				cat
			fi
		} | {
			if $_sf_tn_client_linux; then
				iconv -c -f "UTF8" || :
			else
				iconv -c -f "CP850" || : # IBM850
			fi
		} 2>/dev/null
	}

	trap : PIPE

	case "$_sf_tn_mode" in
		echo)
			tn_raw $'\xff\xfb\x01' # will echo
			tn_raw $'\xff\xfb\x03' # will suppress go-ahead
			tn_raw $'\xff\xfd\x18' # do termtype
			_sf_tn_echo=true
			_sf_tn_raw=false
		;;
		raw)
			_sf_tn_echo=false
			_sf_tn_raw=true
		;;
		*)
			_sf_tn_echo=false
			_sf_tn_raw=false
		;;
	esac

	# hacks
	_sf_tn_first_read=true
	_sf_tn_skip_newline=false

	# sub negotiation
	_sf_tn_subnegotiate=""
	_sf_tn_sub_data=""
	_sf_tn_client_linux=true
}


# convert output for telnet clients
function sf_tn_iconv
{
	{
		if (( $# )); then
			printf '%s' "$*"
		else
			cat
		fi
	} | {
		if $_sf_tn_client_linux; then
			iconv -c -t "UTF8" || :
		else
			iconv -c -t "CP850" || : # IBM850
		fi
	} 2>/dev/null
}


# flush input buffer (probably of \n characters following the \r that triggered an external command)
function sf_tn_flush_input
{
	local c
	while read -r -t 0; do
		LC_ALL=C IFS='' read -r -n 1 -t 1 c 2>/dev/null || :
	done
}

# read a single character from telnet
# NOTE: read with lower case '-n', because 0xff can not be read with -N on bash 4.2
function _sf_tn_read_char
{
	_sf_tn_read_result=128 # timeout
	local __timeout=$((_sf_tn_read_timeout - SECONDS))
	if (( _sf_tn_read_timeout <= 0 )) || ((__timeout >= 0 )); then
		if (( _sf_tn_read_timeout > 0 )); then
			LC_ALL=C IFS='' read -r -n 1 -t "$__timeout" "$1" 2>/dev/null && _sf_tn_read_result=$? || _sf_tn_read_result=$?
		elif (( _sf_tn_read_timeout == 0 )); then
			LC_ALL=C IFS='' read -r -n 1 -t 0			 "$1" 2>/dev/null && _sf_tn_read_result=$? || _sf_tn_read_result=$?
		else
			LC_ALL=C IFS='' read -r -n 1				 "$1" 2>/dev/null && _sf_tn_read_result=$? || _sf_tn_read_result=$?
		fi
		(( _sf_tn_read_result )) || [[ -n "${!1}" ]] || printf -v "$1" '\n'
		if ! (( _sf_tn_read_result )) && ${_sf_tn_debug:-false}; then
			local what
			case "${!1}" in
				$'\xff') what="ESC" ;;
				$'\xf4') what="INT" ;;
				$'\xfb') what="WILL" ;;
				$'\xfc') what="WONT" ;;
				$'\xfd') what="DO" ;;
				$'\xfe') what="DONT" ;;
				$'\xfa') what="SUB BEG, SB" ;;
				$'\xf0') what="SUB END, SE" ;;
				$'\x01') what="ECHO" ;;
				$'\x02') what="RECONNECT" ;;
				$'\x03') what="SUPPRESS GO-AHEAD" ;;
				$'\x04') what="MESSAGE SIZE" ;;
				$'\x05') what="OPT STATUS" ;;
				$'\x06') what="TIMING" ;;
				$'\x07') what="RC PRINTER" ;;
				$'\x08') what="LINE WIDTH" ;;
				$'\x09') what="PAGE LENGTH" ;;
				$'\x0a') what="CARRIAGE RETURN USE" ;;
				$'\x0b') what="HORIZ TAB" ;;
				$'\x0c') what="HORIZ TAB USE" ;;
				$'\x0d') what="FORM FEEDS" ;;
				$'\x0e') what="VERT TAB" ;;
				$'\x0f') what="VERT TAB USE" ;;
				$'\x10') what="LINE FEED USE" ;;
				$'\x11') what="EXTENDED ASCII" ;;
				$'\x12') what="FORCED LOGOUT" ;;
				$'\x13') what="BYTE MACRO" ;;
				$'\x14') what="DATA TERM" ;;
				$'\x15') what="SIGDUP" ;;
				$'\x16') what="SIGDUP OUTPUT" ;;
				$'\x17') what="SEND LOCATE" ;;
				$'\x18') what="TERM TYPE" ;;
				$'\x19') what="END RECORD" ;;
				$'\x1a') what="TACACS ID" ;;
				$'\x1b') what="OUTPUT MARK" ;;
				$'\x1c') what="TERM LOC#" ;;
				$'\x1d') what="3270 REGIME" ;;
				$'\x1e') what="X.3 PAD" ;;
				$'\x1f') what="WINDOW SIZE" ;;
				$'\x20') what="TERMINAL SPEED" ;;
				$'\x21') what="REMOTE FLOW" ;;
				$'\x22') what="LINEMODE" ;;
				*) what='?' ;;
			esac
			printf 'telnet << %s (%s)\n' "$(printf '%s' "${!1}" | xxd -p)" "$what" >&2
		fi
	fi
	return $_sf_tn_read_result
}

# assign variables
function _sf_tn_assign
{
	local __i __input
	read -r __input || :
	for ((__i=0; __i<$#;)); do
		if (( ++__i == $# )); then
			read -r "${!__i}" <<<"$__input"
		else
			read -r "${!__i}" __input <<<"$__input"
		fi
	done
}

# read a line from telnet
function sf_tn_read
{
	if [[ -z "${_sf_tn_raw_fd:-}" ]]; then
		sf_println2 "Error: ShellFunc telnet must be initialized before using $FUNCNAME!"
		return 1
	fi

	local __password=false
	local __unsafe=false
	local __timeout=60
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":pt:uP:" opt; do
		case "$opt" in
			P) printf '%s' "$OPTARG" ;;
			p) __password=true ;;
			u) __unsafe=true ;;
			t)
				__timeout=$OPTARG
				sf_integer -n -v -- "$__timeout" || return 1
			;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if [[ -z "${1:-}" ]]; then
		local __garbage
		set -- "__garbage"
	fi

	_sf_tn_assign "$@" </dev/null

	local _sf_tn_read_timeout=$(( __timeout > 0 ? SECONDS + __timeout : __timeout ))
	local __pos=0
	local __cmd=""
	local __c
	local __i
	local __s
	local __mbPos=""
	while _sf_tn_read_char __c; do
		if $_sf_tn_first_read; then
			_sf_tn_first_read=false
			if [[ "$_sf_tn_mode" = "echo" ]] && [[ "$__c" != $'\xff' ]]; then
				# this client is not negotiating with us
				_sf_tn_mode="raw"
				_sf_tn_raw=true
				_sf_tn_echo=false
			fi
		fi
		if $_sf_tn_skip_newline; then
			_sf_tn_skip_newline=false
			[[ "$__c" != $'\n' ]] || continue
		fi
		if [[ -n $_sf_tn_subnegotiate ]] && [[ "$__c" != $'\xff' ]]; then
			_sf_tn_sub_data+="$__c"
			continue
		fi
		if $_sf_tn_raw; then
			case "$__c" in
				$'\r'|$'\n')
				   [[ "$__c" != $'\r' ]] || _sf_tn_skip_newline=true
					if $__password && ! $__unsafe; then
						_sf_tn_assign "$@" < <(_sf_tn_iconv "$__cmd" | sha256sum | sf_fields 1)
					else
						_sf_tn_assign "$@" < <(_sf_tn_iconv "$__cmd")
					fi
					return 0
				;;
				*) __cmd+="$__c";;
			esac
		else
			case "$__c" in
				$'\xff')
					local __action __code __response=""
					_sf_tn_read_char __action
					case "$__action" in
						$'\xfb') # 251, will
							_sf_tn_read_char __code
							if ! $_sf_tn_echo; then
								__response=$'\xff\xfe'"${__code}" # 254, dont
							else
								case "$__code" in
									$'\x18') # terminal type
										# IAC SB TERMINAL-TYPE SEND IAC SE
										__response=$'\xff\xfa\x18\x01\xff\xf0'
									;;
									*)
										__response=$'\xff\xfe'"${__code}" # 254, dont
									;;
								esac
							fi
						;;
						$'\xfd') # 253, do
							_sf_tn_read_char __code
							if ! $_sf_tn_echo || { [[ "$__code" != $'\x01' ]] && [[ "$__code" != $'\x03' ]]; }; then # allow echo and sga
								__response=$'\xff\xfc'"${__code}" # 252, wont
							fi
						;;
						$'\xfc') # 252, wont
							_sf_tn_read_char __code
						;;
						$'\xfe') # 254, dont
							_sf_tn_read_char __code
						;;
						$'\xf4') # 244, interrupt
							return 69
						;;
						$'\xfa') # 250, begin subnegotiation
							_sf_tn_read_char _sf_tn_subnegotiate # set sub type
							continue
						;;
						$'\xf0') # 240, end subnegotiation
							case "$_sf_tn_subnegotiate" in
								$'\x18') # terminal type
									case "${_sf_tn_sub_data,,}" in
										"ansi")
											_sf_tn_client_linux=false
										;;
									esac
								;;
							esac
							if ${_sf_tn_debug:-false}; then
								printf 'SUB DATA: %s (%s)\n' "$(printf '%s' "$_sf_tn_sub_data" | xxd -p)" "$_sf_tn_sub_data" >&2
							fi
							_sf_tn_subnegotiate=""
							_sf_tn_sub_data=""
							continue
						;;
						$'\xff') # 255, we actually meant to send 255
							:
						;;
						*)
							sf_println2 "Unknown action: $(printf '%s' "$__action" | xxd -p)"
							exit 1
						;;
					esac
					[[ -z "$__response" ]] || tn_raw "$__response"
				;;
				$'\r'|$'\n')
					[[ "$__c" != $'\r' ]] || _sf_tn_skip_newline=true
					if $_sf_tn_echo; then
						println
					fi
					if $__password && ! $__unsafe; then
						_sf_tn_assign "$@" < <(_sf_tn_iconv "$__cmd" | sha256sum | sf_fields 1)
					else
						_sf_tn_assign "$@" < <(_sf_tn_iconv "$__cmd")
					fi
					return 0
				;;
				$'\x03') # 3, windows interrupt
					return 69
				;;
				$'\x1b') # 27, arrows
					_sf_tn_read_char __action
					_sf_tn_read_char __code
					if [[ "$__action" = $'\x5b' ]] && $_sf_tn_echo; then
						case "$__code" in
							$'\x31'|$'\x37') # home
								_sf_tn_read_char __code
								for ((; __pos>0; __pos--)); do
									tn_raw $'\x1b\x5b\x44' # left
								done
							;;
							$'\x32') # insert
								_sf_tn_read_char __code
							;;
							$'\x33') # delete
								_sf_tn_read_char __code

								# position must be less than the length of the current command
								(( __pos < ${#__cmd} )) || continue

								# erase character from command
								__cmd="${__cmd:0:__pos}${__cmd:__pos+1}"

								# write to end of command, space, then backpedal
								_sf_tn_autostar "${__cmd:__pos}"
								tn_raw " "
								for ((__c=${#__cmd} + 1; __c>__pos; __c--)); do
									tn_raw $'\x1b\x5b\x44' # left
								done
							;;
							$'\x34'|$'\x38') # end
								_sf_tn_read_char __code
								for ((; __pos<${#__cmd}; __pos++)); do
									tn_raw $'\x1b\x5b\x43' # right
								done
							;;
							$'\x35') # page up
								_sf_tn_read_char __code
							;;
							$'\x36') # page down
								_sf_tn_read_char __code
							;;
							$'\x43') # C, right
								if (( __pos < ${#__cmd} )); then
									(( ++__pos ))
									tn_raw "${__c}${__action}${__code}"
								fi
							;;
							$'\x44') # D, left
								if (( __pos )); then
									(( __pos-- ))
									tn_raw "${__c}${__action}${__code}"
								fi
							;;
						esac
					fi
				;;
				$'\x08') # backspace
					if (( __pos )) && $_sf_tn_echo; then

						# reduce position
						(( __pos-- ))
						tn_raw $'\x1b\x5b\x44' # left

						# erase character from command
						__cmd="${__cmd:0:__pos}${__cmd:__pos+1}"

						# write to end of command, space, then backpedal
						_sf_tn_autostar "${__cmd:__pos}"
						tn_raw " "
						for ((__c=${#__cmd} + 1; __c>__pos; __c--)); do
							tn_raw $'\x1b\x5b\x44' # left
						done
					fi
				;;
				$'\x7f') # delete
					if (( ${#__cmd} )) && $_sf_tn_echo; then

						# linux client? if so, act like backspace
						if $_sf_tn_client_linux; then
							(( __pos )) || continue
							(( __pos-- ))
							tn_raw $'\x1b\x5b\x44' # left
						fi

						# position must be less than the length of the current command
						(( __pos < ${#__cmd} )) || continue

						# erase character from command
						__cmd="${__cmd:0:__pos}${__cmd:__pos+1}"

						# write to end of command, space, then backpedal
						_sf_tn_autostar "${__cmd:__pos}"
						tn_raw " "
						for ((__c=${#__cmd} + 1; __c>__pos; __c--)); do
							tn_raw $'\x1b\x5b\x44' # left
						done
					fi
				;;
				*)
					__c=$(sf_printable "$__c")
					if [[ -n "$__c" ]]; then
						if ! $_sf_tn_echo; then
							__cmd="${__cmd:0:__pos}${__c}${__cmd:__pos}" && (( ++__pos ))
						else
							# get old length
							__s="$(_sf_tn_iconv "$__cmd")"
							__i="${#__s}"

							# add new byte
							__cmd="${__cmd:0:__pos}${__c}${__cmd:__pos}" && (( ++__pos ))

							# if length didn't change, we're writing a multibyte
							__s="$(_sf_tn_iconv "$__cmd")"
							if (( ${#__s} == __i )); then
								# consider setting the end position of the multibyte
								if [[ -z "$__mbPos" ]]; then
									__mbPos="$((__pos))"
								fi
							else
								# did we just end a multibyte?
								if [[ -n "$__mbPos" ]]; then
									__pos="$__mbPos"
									__mbPos=""
								fi

								# write to end of command, then backpedal
								_sf_tn_autostar "${__cmd:__pos-1}"
								for ((__c=${#__cmd}; __c>__pos; __c--)); do
									tn_raw $'\x1b\x5b\x44' # left
								done
							fi
						fi
					fi
				;;
			esac
		fi
	done
	return $_sf_tn_read_result
}

# export functions from a reasonably structured library
function sf_export
{
	if (( $# < 2 )); then
		sf_println2 "Usage: $FUNCNAME <lib> <func> [func] ..."
		return $(( $# ? 1 : 0 ))
	fi

	local lib=$1
	shift

	if ! sf_goodfile -qv "$lib"; then
		return 1
	fi

	local lines
	lines=$(sf_wc -l <"$lib")

	local func
	for func; do
		local begin=""
		local src=false
		if
			begin=$(grep -n -m1 '^[[:space:]]*'"$func"'[[:space:]]*()' "$lib") ||
			begin=$(grep -n -m1 '^[[:space:]]*function[[:space:]][[:space:]]*'"$func"'\([[:space:]]\|{\|$\)' "$lib")
		then
			begin=${begin%%:*}
			local i
			for ((i=1; i<lines; i++)); do
				if tail -n +"$begin" "$lib" | head -n "$i" | bash >/dev/null 2>&1; then
					tail -n +"$begin" "$lib" | head -n "$i"
					sf_println
					src=true
					break
				fi
			done
		fi
		if ! $src; then
			sf_println2 "Error: Unable to extract function: $func"
			return 1
		fi
	done
}

# check shutdown state - for (almost) endless loops
function sf_true
{
	local file="/tmp/.shutdown"
	if ! [[ -e "$file" ]] || [[ "$(cat "$file")" = "false" ]]; then
		return 0
	else
		return 1
	fi
}

# create temporary fifo's and files with random names
# checks for collisions and *should* always succeed
function sf_mknod {
	# get options
	local _path
	_path="$(sf_tmpdir)"
	local _verbose=false
	local _fullpath=""
	local _legacy=false
	local _name=""
	local _output=""
	local _rmqueue=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":f:ln:o:p:qv" opt; do
		case "$opt" in
			f) _fullpath=${OPTARG}; _legacy=true ;;
			l) _legacy=true ;;
			n) _name=${OPTARG} ;;
			o) _output=${OPTARG} ;;
			p) _path=${OPTARG} ;;
			q) _rmqueue=true ;;
			v) _verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if [[ -z "$_path" ]]; then
		sf_println2 "Error: Unable to acquire temp directory!"
		return 1
	fi

	if [[ -n "$_output" ]]; then
		case "$_output" in
			# case ") => ;&" instead of ") => ;;" allows fall-through, but only on bash 4
			# thus the following line is damn long :)
			_verbose|_fullpath|_legacy|_name|_output|_path|_rmqueue|_node|_file|OPTIND|OPTARG|OPTERR|opt)
				sf_println2 "Error: Invalid variable name: ${_output}"
				sf_println2 "This variable is used internally in $FUNCNAME and is thus not allowed as an _output variable"
				return 1
			;;
			*)
				! $_verbose || sf_println2 "Output goes to \$${_output}"
			;;
		esac
	fi

	# did we specify the full path?
	if [[ -n "$_fullpath" ]]; then
		_name=$(basename "$_fullpath")
		_path=$(dirname "$_fullpath")
	fi

	# check node type
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME [options] <\"dir\"|\"fifo\"|\"file\">"
		return 1
	fi
	local type=${1}
	case "$type" in
		dir)
			if $_rmqueue; then
				sf_println2 "Error: The rmqueue does not support directories!"
				return 1
			fi
			local _name=${_name:-"dir"}
			_legacy=true
		;;
		fifo) local _name=${_name:-"fifo"}; _legacy=true ;;
		file) local _name=${_name:-"file"} ;;
		*)
			sf_println2 "Error: Unsupported _node type \"$type\""
			return 1
		;;
	esac

	# correct path
	_path=$(sf_slashpath "$_path")
	if ! [[ -d "$_path" ]] || ! [[ -w "$_path" ]]; then
		sf_println2 "Error: Path \"$_path\" does not exist or can not be written to!"
		return 1
	fi

	while true; do
		local _node="${_path}${_name}"
		if $_legacy; then
			if [[ -z "$_fullpath" ]]; then
				_node="$(sf_dashstring "$_node")${RANDOM}"
			fi
			! $_verbose || sf_println2 "Attempting to make ${type}: \"$_node\""
		fi
		case "$type" in
			dir)
				(umask 0077 && mkdir "$_node") &>/dev/null && break || :
			;;
			fifo)
				(umask 0077 && mkfifo "$_node") &>/dev/null && break || :
			;;
			file)
				if ! $_legacy; then
					local _file
					_file=$(umask 0077 && mktemp "${_node}-XXXXXX" 2>/dev/null) &&
					_node=${_file} &&
					! $_verbose || sf_println2 "Attempting to make ${type}: \"$_node\"" &&
					break || :
				elif ! [[ -e "${_node}" ]]; then
					(set -C && umask 0077 && >"${_node}") &>/dev/null && break || :
				fi
			;;
		esac
		! $_verbose || sf_println2 "Failed to create ${_node}!"
		if [[ -n "$_fullpath" ]]; then return 1; fi
		sleep 0.1 || return 1
	done
	
	! $_verbose || sf_println2 "Success!"

	if $_rmqueue; then
		if $_verbose; then 
			sf_rm_queue -v "$_node"
		else
			sf_rm_queue "$_node"
		fi
	fi

	if [[ -z "$_output" ]]; then
		sf_println "$_node"
	else
		printf -v "$_output" "%s" "$_node"
	fi
	return 0
}
function sf_mkfile { sf_mknod "$@" "file"; }
function sf_mkfifo { sf_mknod "$@" "fifo"; }
function sf_mkdir { sf_mknod "$@" "dir"; }

# grep in a given field only
function sf_fgrep
{
	local grep_opts=()
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":q" opt; do
		case "$opt" in
			q) grep_opts+=( '-q' ) ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi

	if (( $# < 2 )); then
		sf_println2 "Usage: $FUNCNAME <field> <regex>"
		return 1
	fi

	local field=$1
	sf_integer -v -- "$field" || return $?
	if ! (( field )); then
		sf_println2 "Error: Field numbering starts at 1, like awk, because it is"
		return 1
	fi
	shift

	local regex="$*"
	awk "\$${field}~/${regex//\//\\\/}/" | grep "${grep_opts[@]}" ^
}

# rudimentary json parser for simple structures only
# returns 0 if the field was found, empty or not
# returns 1 if the field was not found
function sf_json
{
	local lower=false
	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":l" opt; do
		case "$opt" in
			l) lower=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	if (( $# != 2 )); then
		sf_println2 "Usage: $FUNCNAME <blob> <field>"
		return 1
	fi
	local blob=$1 field=$2
	if [[ "$blob" = "-" ]]; then
		blob=$(cat)
	fi

	local match
	match=$(
		shopt -s nocasematch
		regex="\"$field\"\\s*:\\s*(.+)"
		if [[ "$blob" =~ $regex ]]; then
			if [[ "${BASH_REMATCH[1]}" = '"'* ]]; then
				sf_print "${BASH_REMATCH[1]}"
			else
				regex="([^ ,;}]*)"
				if [[ "${BASH_REMATCH[1]}" =~ $regex ]]; then
					sf_print "${BASH_REMATCH[1]}"
				fi
			fi
		fi
	)

	case "$match" in
		'') return 1 ;;
		'"'*)
			local esc=false
			local result=""
			while IFS= read -r -n 1 c; do
				case "$c" in
					"\\") $esc && esc=false || esc=true; continue ;;
					'"')
						$esc || break
						esc=false
					;;
					*)
						if $esc; then
							result+="\\"
							esc=false
						fi
					;;
				esac
				result+="$c"
			done <<<"${match:1}"
			read -r result <<<"$result"
			! $lower || result="${result,,}"
			echo -e "$result"
		;;
		*)
			sf_println "$match"
		;;
	esac
}

# save filename in a list of stuff which is deleted when sf_rm_process runs
function sf_rm_queue
{
	local verbose=false
	local printname=false
	local force=false
	local file

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":vVf" opt; do
		case "$opt" in
			f) force=true ;;
			v) verbose=true ;;
			V) printname=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME [-vV] <file> [file] ..."
		return 1
	fi

	if [[ -z "${sf_rm_array[*]:-}" ]]; then
		sf_rm_array=()
		! $verbose || sf_println2 "rm_queue is currently empty."
	else
		! $verbose || sf_println2 "rm_queue currently holds ${#sf_rm_array[*]} item(s)."
	fi

	while [[ -n "${1:-}" ]]; do
		if ! [[ -e "$1" ]] && ! $force; then
			sf_println2 "Warning: File \"${1}\" does not exist!"
			sf_println2 "Warning: Not adding to rm_queue!"
			shift
			continue
		fi
		if [[ -n "${sf_rm_array[*]:-}" ]]; then
			for file in "${sf_rm_array[@]}"; do
				if [[ "$file" = "$1" ]]; then
					sf_println2 "Warning: File \"${1}\" is already in the rm_queue!"
					sf_println2 "Warning: Not adding it again!"
					shift
					continue 2
				fi
			done
		fi
#		sf_rm_array=( "${sf_rm_array[@]-}" "${1}" )
#		sf_rm_array+=( "${1}" ) # bash >=3.1
		sf_rm_array[${#sf_rm_array[*]}]="$1"
		! $verbose || sf_println2 "\"${1}\" marked for deletion!"
		if $printname; then sf_println "${1}"; fi
		shift
	done
	
	! $verbose || sf_println2 "rm_queue now holds ${#sf_rm_array[*]} item(s)."
}

# abort removal of a file
function sf_rm_abort
{
	local verbose=false
	local printname=false

	local r
	local i
	local file

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":v" opt; do
		case "$opt" in
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	if (( $# == 0 )); then
		sf_println2 "Usage: $FUNCNAME [-v] <file> [file] ..."
		return 1
	fi

	while [[ -n "${1:-}" ]]; do
		r=0
		if [[ -n "${sf_rm_array[*]:-}" ]]; then
			for file in "${sf_rm_array[@]}"; do
				if [[ "$file" = "$1" ]]; then
					! $verbose || sf_println2 "Found \"${1}\" as element ${r}"
					size=${#sf_rm_array[*]}
					unset "sf_rm_array[$r]"
					for (( i=r; i < (size-1); i++ )); do
						sf_rm_array[i]=${sf_rm_array[$((i+1))]}
					done
					unset "sf_rm_array[$((size-1))]"
					! $verbose || sf_println2 "Removed. $((size-1)) element(s) remaining in rm_queue."
					shift
					continue 2
				fi
				(( ++r ))
			done
		fi
		! $verbose || sf_println2 "\"${1}\" is not in the rm_queue and can therefore not be removed from it!"
		shift
	done
}


# rm items in rm_array
function sf_rm_process
{
	local verbose=false
	local file

	local OPTIND=1 OPTARG OPTERR opt
	while getopts ":v" opt; do
		case "$opt" in
			v) verbose=true ;;
			[?])
				sf_error_unknown_option
				return 1
			;;
			:)
				sf_error_missing_argument
				return 1
			;;
		esac
	done
	shift $((OPTIND-1))
	if [[ "${1:-}" = "--" ]]; then shift; fi
	
	if (( $# != 0 )); then
		sf_println2 "Usage: $FUNCNAME [-v]"
		return 1
	fi

	! $verbose || sf_println2 "Processing the rm_queue..."
	if [[ -z "${sf_rm_array[*]:-}" ]]; then
		! $verbose || sf_println2 "The rm_queue is empty. Not doing anything."
		return 0
	fi
	! $verbose || sf_println2 "${#sf_rm_array[*]} files to remove..."
	(
		set +e
		for file in "${sf_rm_array[@]}"; do
			if [[ -e "$file" ]]; then
				rm -f "$file" && ! $verbose || sf_println2 "Removed \"$file\""
			else
				! $verbose || sf_println2 "Missing file not removed: \"$file\""
			fi
		done
	)

	unset sf_rm_array

	! $verbose || sf_println2 "Done!"
}

# convert simple timespans to seconds
function sf_timespan2seconds
{
	local ts="${*,,}"
	ts=$(tr -c -d '[:alnum:]' <<<"$ts")
	local regex='^[0-9]+[a-z]?$'
	if [[ "$ts" =~ $regex ]]; then
		regex='[^0-9]'
		if [[ "$ts" =~ $regex ]]; then
			local unit="${ts: -1}"
			ts="${ts::-1}"
			case "$unit" in
				s) ;;
				m) ts=$(( ts * 60 )) ;;
				h) ts=$(( ts * 3600 )) ;;
				d) ts=$(( ts * 86400 )) ;;
				*)
					sf_println2 "Error: ${FUNCNAME}: Invalid unit in timestamp: ${ts}${unit}"
					return 1
				;;
			esac
		fi
		sf_println "$ts"
	else
		sf_println2 "Error: ${FUNCNAME}: Invalid timestamp: ${ts}"
		return 1
	fi
}

# convert seconds to days, hours, minutes and seconds
function sf_seconds2days
{
	if (( $# != 1 )) || ! sf_integer -v "$1"; then
		return 1
	fi

	printf '%d days, %02d:%02d:%02d\n' \
	$(( $1 / 86400 )) \
	$(( $1 / 3600 % 24 )) \
	$(( $1 / 60 % 60 )) \
	$(( $1 % 60 )) |
	sed 's/^1\ days/1\ day/;s/^0\ days,\ //;s/^00://;s/^0//'
}
function sf_seconds2dayslong
{
	if (( $# != 1 )) || ! sf_integer -v "$1"; then
		return 1
	fi
	local d=$(( $1 / 86400 ))
	local h=$(( $1 / 3600 % 24 ))
	local m=$(( $1 / 60 % 60 ))
	local s=$(( $1 % 60 ))
	local out=""
	if (( d > 1 )); then
		out="$d days"
	elif (( d == 1 )); then
		out="1 day"
	fi
	if [[ -n "$out" ]] && (( h+m+s > 0 )); then
		if
			{ (( h > 0 )) && (( m > 0 )); } ||
			{ (( h > 0 )) && (( s > 0 )); } ||
			{ (( m > 0 )) && (( s > 0 )); }
		then
			out="${out}, "
		else
			out="${out} and "
		fi
	fi
	if (( h > 1 )); then
		out="${out}$h hours"
	elif (( h == 1 )); then
		out="${out}$h hour"
	fi
	if [[ -n "$out" ]] && (( h != 0 )) && (( m+s > 0 )); then
		if (( m > 0 )) && (( s > 0)); then
			out="${out},"
		fi
		out="${out} "
		if (( m == 0 )) || (( s == 0 )); then
			out="${out}and "
		fi
	fi
	if (( m > 1 )); then
		out="${out}$m minutes"
	elif (( m == 1 )); then
		out="${out}$m minute"
	fi
	if [[ -n "$out" ]] && (( m != 0 )) && (( s > 0 )); then
		out="${out} and "
	fi
	if (( s > 1 )); then
		out="${out}$s seconds"
	elif (( s == 1 )); then
		out="${out}$s second"
	fi
	if [[ -z "$out" ]]; then
		out="0 seconds"
	fi
	sf_println "$out"
}

# get the full path of a file
function sf_fullpath
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi
	
	(
		if ! cd "$(dirname "$1")" 2>/dev/null; then
			sf_println2 "Error: Directory \"$(dirname "$1")\" does not exist!"
			return 1
		fi
		sf_println "$(pwd -L)/$(basename "$1")"
	)
}

# get the real path of a file
function sf_realpath
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <file>"
		return 1
	fi

	(
		if [[ -d "$1" ]]; then
			cd "$1"
			sf_println "$(pwd -P)"
		else
			cd "$(dirname "$1")"
			sf_println "$(pwd -P)/$(basename "$1")"
		fi
	)
}

# get the ip address of an interface
function sf_ifip
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <IFACE>"
		return $(( $# ? 1 : 0 ))
	fi
	local ip
	ip=$(
		ip addr |
			grep -E "[[:space:]]+inet .* scope global.* ${1}$" |
			awk '{print $2}' |
			cut -d '/' -f1 |
			head -n 1
	)
	if [[ -n "$ip" ]] && sf_ipv4 "$ip"; then
		sf_println "$ip"
	else
		sf_println2 "Error: Failed to get local IP address of interface $1"
		return 1
	fi
}

# get parameters from haproxy (used alongside tcpserver)
function sf_haproxy_readline
{
	local line
	if ! read -r -t 10 line; then
		sf_println2 "Error: Failed to read PROXY line!"
		exit 1
	fi
	if [[ "${line,,}" = "watchdog" ]]; then
		exit 0 # allows watchdogs for haproxy services in docker
	fi
	local array
	read -ra array <<<"$line"
	set -- "${array[@]}"
	if [[ "${1,,}" != "proxy" ]]; then
		sf_println2 "Error: First line from client was not the PROXY command!"
		sf_println2 "Error: --> $line <--"
		exit 1
	fi
	#PROXY TCP6 ::ffff:89.242.15.13 ::ffff:233.27.8.10 30711 1024
	TCPREMOTEIP="${3#"::ffff:"}"
	TCPLOCALIP="${4#"::ffff:"}"
	TCPLOCALPORT="${6%$'\r'}" # cut the carriage return from the end of the line
}

# calculate levenshtein distance between two strings
function sf_strdiff
{
	if (( $# != 2 )); then
		sf_println2 "Usage: $FUNCNAME <string1> <string2>"
		return $(( $# ? 1 : 0 ))
	fi
	if [[ "$1" = "$2" ]]; then
		sf_println 100 # this avoids "-nan" output from awk when comparing two empty strings
		return 0
	fi
	awk '
		function min(x, y)
		{
			return x < y ? x : y
		}
		function max(x, y)
		{
			return x > y ? x : y
		}
		function lev(s,t)
		{
			m = length(s)
			n = length(t)
			for(i=0;i<=m;i++) d[i,0] = i
			for(j=0;j<=n;j++) d[0,j] = j
			for(i=1;i<=m;i++) {
				for(j=1;j<=n;j++) {
					c = substr(s,i,1) != substr(t,j,1)
					d[i,j] = min(d[i-1,j]+1,min(d[i,j-1]+1,d[i-1,j-1]+c))
				}
			}
			return d[m,n]
		}

		BEGIN {
			print 100 * lev(ARGV[1], ARGV[2]) / max(length(ARGV[1]), length(ARGV[2]))
			exit
		}
	' "$1" "$2"
}

# do that whole ipv4 network calculator thing
function sf_ipv4calc
{
	if (( $# != 1 )); then
		sf_println2 "Usage: $FUNCNAME <CIDR>"
		return $(( $# ? 1 : 0 ))
	fi
	local ip mask bin s
	IFS='/' read -r ip mask <<<"$1"
	if sf_ipv4 "$mask"; then
		s=$(sf_ipv42bin "$mask")
		s=${s%%0*}
		mask=${#s}
	fi
	bin=$(sf_ipv42bin "$ip")
	printf -v s '%-32s' "${bin::$mask}"
	printf '%-11s%s\n' "Network:" "$(sf_bin2ipv4 "${s// /0}")"
	printf '%-11s%s\n' "Broadcast:" "$(sf_bin2ipv4 "${s// /1}")"
	s=${s::31}
	printf '%-11s%s\n' "First IP:" "$(sf_bin2ipv4 "${s// /0}1")"
	printf '%-11s%s\n' "Last IP:" "$(sf_bin2ipv4 "${s// /1}0")"
	printf '%-11s%s\n' "CIDR:" "$(sf_bin2ipv4 "${s// /0}0")/$mask"
	printf -v s "%$((mask))s"
	printf -v s '%-32s' "${s// /1}"
	printf '%-11s%s\n' "Mask:" "$(sf_bin2ipv4 "${s// /0}")"
	printf -v s "%$((32-mask))s"
	printf '%-11s%s\n' "IP count:" "$((2#${s// /1}-1))"
}
